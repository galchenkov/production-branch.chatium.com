import { Fragment as JsxFragment } from './appUi'
import { Static } from '@sinclair/typebox'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import {
  HeapObjectBaseSchema,
  HeapObjectBaseV2,
  HeapSchema,
  HsFilterInput,
  HsFilterInputObject,
  HsObject,
  HsProperties,
  HsProperty,
} from 'core/heap/v2/heapSchemaTypes'
import { HeapOrderByV2, HeapRecordFilter, HeapRecordSelectOptions } from 'core/heap/v2/types'
import {
  ApiCallAction,
  ApiCallResponseFields,
  ApiCallSuccessResponse,
  AttachMediaAction,
  ChatiumActions,
  ChatiumScreen,
  NavigateAction,
  QueryParamsOption,
  SubmitFormAction,
  apiCall,
  navigate,
} from 'lib/chatium-json'
import {
  ChatiumErrorResponse,
  ChatiumJsonId,
  ChatiumJsonKey,
  Color,
  Icon,
  TuneHttpHeadersResponse,
} from 'lib/chatium-json/v1'
import { CtxOutsideFns } from 'services/ugc-runner/runtime/runtimeTypes'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'

declare type OrderByDefinition<T> = SingleOrderBy<T> | Array<SingleOrderBy<T>>
declare type SortDirection =
  | 'asc'
  | 'desc'
  | 'asc nulls first'
  | 'asc nulls last'
  | 'desc nulls first'
  | 'desc nulls last'
declare type ValueTypeHint = '$string' | '$number' | '$date' | '$boolean'
declare type SingleOrderBy<T> = (keyof T & string) | ObjectOrderVariant<T>
declare type ObjectOrderVariant<T> = {
  [Field in keyof T & string]?: SingleOrderByValue<T[Field]>
}
declare type SingleOrderByValue<V> = V extends object
  ? ObjectOrderVariant<V>
  : SortDirection | ValueTypeHint | [ValueTypeHint, SortDirection]
declare type JSONTemplateCondition =
  | string
  | number
  | {
      $or: Array<JSONTemplateCondition>
    }
  | {
      $and: Array<JSONTemplateCondition>
    }
  | {
      [key: string]: JSONTemplateCondition | null
    }
declare type JSONTemplate$IF<T> = {
  $if: JSONTemplateCondition
  $then?: JSONTemplate<T>
  $else?: JSONTemplate<T>
}
declare type JSONTemplate$VAR = {
  $var: JSONTemplateCondition
}
declare type JSONTemplate<T> = T | JSONTemplate$IF<T> | JSONTemplate$VAR
declare type JSONTemplatableObject<T> = {
  [Property in keyof T]: JSONTemplatableValue<T[Property]>
}
declare type JSONTemplatableValue<T> = unknown extends T
  ? JSONTemplate<T>
  : [T] extends [Scalar]
  ? JSONTemplate<T>
  : T extends AnyTuple
  ? JSONTemplatableObject<T>
  : T extends Array<infer Value>
  ? Array<JSONTemplatableValue<Value>>
  : T extends object
  ? JSONTemplatableObject<T> | JSONTemplate<JSONTemplatableObject<T>>
  : JSONTemplate<T>
declare type JSONTemplateRecursive<T> = JSONTemplatableValue<T>
declare type NumericLiteral = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
declare type AnyTuple = {
  [index: string]: any
} & {
  length: NumericLiteral
}
declare type Scalar = string | number | boolean | null | undefined
declare type JSONValue = string | number | boolean | null | JSONValue[] | JSONObject
declare type JSONObject = {
  [key: string]: JSONValue
}
declare type JSONInputValue = string | number | boolean | null | JSONInputValue[] | JSONInputObject | undefined
declare type JSONInputObject = {
  [key: string]: JSONInputValue
}
declare type PublicFieldsOfClass<T> = {
  [Property in keyof T]: T[Property]
}
declare type MessageSticker = {
  url: string
  previewUrl?: string
  emoji?: string[]
}
declare type SpacingValue =
  | number
  | 'safeAreaInsetTop'
  | 'safeAreaInsetRight'
  | 'safeAreaInsetBottom'
  | 'safeAreaInsetLeft'
  | 'smartMinTopSpacing'
  | 'headerInsetTop'
interface PaddingStyle {
  padding?:
    | SpacingValue
    | [SpacingValue, SpacingValue]
    | [SpacingValue, SpacingValue, SpacingValue]
    | [SpacingValue, SpacingValue, SpacingValue, SpacingValue]
  paddingVertical?: SpacingValue
  paddingHorizontal?: SpacingValue
  paddingLeft?: SpacingValue
  paddingRight?: SpacingValue
  paddingTop?: SpacingValue
  paddingBottom?: SpacingValue
}
interface MarginStyle {
  margin?:
    | SpacingValue
    | [SpacingValue, SpacingValue]
    | [SpacingValue, SpacingValue, SpacingValue]
    | [SpacingValue, SpacingValue, SpacingValue, SpacingValue]
  marginVertical?: SpacingValue
  marginHorizontal?: SpacingValue
  marginLeft?: SpacingValue
  marginRight?: SpacingValue
  marginTop?: SpacingValue
  marginBottom?: SpacingValue
}
interface BorderStyle extends BorderStyleNoRadius, BorderRadiusStyle {}
interface BorderStyleNoRadius extends BorderColorStyle, BorderStyleStyle, BorderWidthStyle {
  border?: [BorderWidth, BorderStyles, Color]
  borderBottom?: BorderShortDef
  borderLeft?: BorderShortDef
  borderRight?: BorderShortDef
  borderTop?: BorderShortDef
}
declare type BorderShortDef = [BorderWidth, Color]
interface BorderStyleStyle {
  borderStyle?: BorderStyles
}
declare type BorderStyles = 'solid' | 'dotted' | 'dashed'
interface BorderRadiusStyle {
  borderBottomLeftRadius?: number
  borderBottomRightRadius?: number
  borderRadius?: number | [number, number, number, number]
  borderTopLeftRadius?: number
  borderTopRightRadius?: number
}
interface BorderWidthStyle {
  borderBottomWidth?: BorderWidth
  borderLeftWidth?: BorderWidth
  borderRightWidth?: BorderWidth
  borderTopWidth?: BorderWidth
  borderWidth?:
    | BorderWidth
    | [BorderWidth, BorderWidth]
    | [BorderWidth, BorderWidth, BorderWidth]
    | [BorderWidth, BorderWidth, BorderWidth, BorderWidth]
}
declare type BorderWidth = 'hairline' | number
interface BorderColorStyle {
  borderBottomColor?: Color
  borderLeftColor?: Color
  borderRightColor?: Color
  borderTopColor?: Color
  borderColor?: Color | [Color, Color] | [Color, Color, Color] | [Color, Color, Color, Color]
}
interface BoxPositionStyle {
  bottom?: PxOrPercentOrAuto
  left?: PxOrPercentOrAuto
  position?: 'absolute' | 'relative'
  right?: PxOrPercentOrAuto
  top?: PxOrPercentOrAuto
}
declare type BoxSizingStyle = BoxSizingWidthStyle & BoxSizingHeightStyle
interface BoxSizingWidthStyle {
  width?: PxOrPercentOrAuto
  maxWidth?: PxOrPercentOrAuto
  minWidth?: PxOrPercentOrAuto
}
interface BoxSizingHeightStyle {
  height?: PxOrPercentOrAuto
  maxHeight?: PxOrPercentOrAuto
  minHeight?: PxOrPercentOrAuto
}
interface BoxOverflowStyle {
  overflow?: 'visible' | 'hidden'
}
interface BoxPointerEventsStyle {
  pointerEvents?: 'auto' | 'none' | 'box-none' | 'box-only'
}
declare type SimpleBgColorStyle = BackgroundColorStyle & OpacityStyle
interface BackgroundColorStyle {
  backgroundColor?: Color
}
interface OpacityStyle {
  opacity?: number
}
interface ColorStyle {
  color?: Color
}
interface BackgroundGradientStyle {
  backgroundGradient?: [GradientDirection, ...GradientColor[]] | GradientColor[]
}
declare type GradientColor = Color | [Color, number]
declare type GradientDirection = 'to right' | 'to left' | 'to bottom' | 'to top' | number
declare type BoxColorStyle = SimpleBgColorStyle & BackgroundGradientStyle
declare type PxOrPercent = number | string
declare type PxOrPercentOrAuto = PxOrPercent | 'auto'
interface FlexStyle extends FlexContainerStyle, SelfAlignFlexStyle, SelfFlexStyle {}
interface FlexContainerStyle {
  alignContent?: 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'space-between' | 'space-around'
  alignItems?: FlexAlignType
  flexDirection?: 'row' | 'column' | 'row-reverse' | 'column-reverse'
  flexWrap?: 'wrap' | 'nowrap' | 'wrap-reverse'
  justifyContent?: 'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-around' | 'space-evenly'
}
interface SelfAlignFlexStyle {
  alignSelf?: 'auto' | FlexAlignType
}
interface SelfFlexStyle {
  flex?: number
  flexBasis?: 'auto' | PxOrPercent
  flexGrow?: number
  flexShrink?: number
}
declare type FlexAlignType = 'flex-start' | 'flex-end' | 'center' | 'stretch' | 'baseline'
interface TextStyle {
  color?: Color
  fontFamily?: 'serif' | 'sans' | 'mono' | string
  fontSize?: number | StandardFontSize
  fontStyle?: 'normal' | 'italic'
  fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'
  fontVariant?: ('normal' | 'tabular-nums')[]
  letterSpacing?: 'normal' | number
  lineClamp?: number
  lineHeight?: 'normal' | number
  textAlign?: 'auto' | 'left' | 'right' | 'center' | 'justify'
  textAlignVertical?: 'top' | 'center' | 'bottom'
  textDecorationLine?: 'none' | 'underline' | 'line-through' | 'underline line-through'
  textOverflow?: 'clip' | 'ellipsis'
  textShadowColor?: Color
  textShadowOffset?: {
    width: number
    height: number
  }
  textShadowRadius?: number
  textTransform?: 'none' | 'uppercase' | 'lowercase' | 'capitalize'
}
declare type StandardFontSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl'
interface TransformStyle {
  transform?: (
    | PerspectiveTransform
    | RotateTransform
    | RotateXTransform
    | RotateYTransform
    | RotateZTransform
    | ScaleTransform
    | ScaleXTransform
    | ScaleYTransform
    | TranslateXTransform
    | TranslateYTransform
    | SkewXTransform
    | SkewYTransform
    | MatrixTransform
  )[]
}
interface ShadowStyle {
  elevation?:
    | null
    | 0
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16
    | 17
    | 18
    | 19
    | 20
    | 21
    | 22
    | 23
    | 24
  shadowColor?: Color
}
interface PerspectiveTransform {
  perspective: number
}
interface RotateTransform {
  rotate: number | string
}
interface RotateXTransform {
  rotateX: number | string
}
interface RotateYTransform {
  rotateY: number | string
}
interface RotateZTransform {
  rotateZ: number | string
}
interface ScaleTransform {
  scale: number
}
interface ScaleXTransform {
  scaleX: number
}
interface ScaleYTransform {
  scaleY: number
}
interface TranslateXTransform {
  translateX: number
}
interface TranslateYTransform {
  translateY: number
}
interface SkewXTransform {
  skewX: string
}
interface SkewYTransform {
  skewY: string
}
interface MatrixTransform {
  matrix: [number, number, number, number, number, number]
}
declare type SingleOrArray<T> = T | T[]
declare type PlainOrPromise<T> = T | Promise<T>
declare type SingleOrArrayRecursive<T> = T | T[] | Array<SingleOrArrayRecursive<T>>
declare type SingleOrArrayRecursiveNullable<T> = SingleOrArrayRecursive<T | null | undefined | false>
declare type TextOrBlock = JSONTemplate<string | number | null | undefined | ChatiumBlockV2>
declare type BlockClass<T> = SingleOrArrayRecursiveNullable<JSONTemplateRecursive<T>>
declare type BlockStyle<T> = SingleOrArrayRecursiveNullable<JSONTemplateRecursive<T>>
declare type BlockProperty<T> = JSONTemplateRecursive<T>
declare type BlockActions = ChatiumActions
interface CommonBlockProps {
  /**
   * Helps client-side rendering optimization
   * Auto-generated using consistent compact algorithm, but can be provided by developer manually
   * When provided by developer manually, should be unique only on local level
   *  and is augmented/modified automatically to be unique on screen level
   */
  key?: ChatiumJsonKey
  /**
   * The main meaning is block unique ID
   * This is also translated to client-side key of component, but is slightly different than key itself:
   *  1) It's not auto-generated
   *  2) Is passed without any modifications, uniqueness must be provided by the developer
   *  3) Due to (2) can be used for actions that require some manipulations pointing to the exact block
   */
  id?: ChatiumJsonId
  /**
   * Allows to conditionally render this block based on state condition
   */
  $if?: JSONTemplateCondition
}
interface AudioBlock extends AudioProps {
  type: 'audio'
}
interface AudioProps extends CommonBlockProps {
  src: BlockProperty<{
    url: string
    durationSeconds?: number
  }>
  title?: BlockProperty<string>
  subTitle?: BlockProperty<string>
  class?: BlockClass<AudioClasses>
  style?: BlockStyle<AudioProps.Style>
  onContext?: BlockActions
}
declare namespace AudioProps {
  type Style = AudioStyle
}
declare type AudioClasses = 'section'
declare type AudioStyle = MarginStyle &
  BorderStyle &
  SelfFlexStyle &
  SelfAlignFlexStyle &
  BoxPositionStyle &
  BoxSizingStyle &
  BoxColorStyle &
  ColorStyle &
  PaddingStyle &
  ShadowStyle
declare type ChatiumChildNode = SyncNode | Promise<SyncNode>
declare type SyncNode = JSONTemplate<SingleNode> | Array<JSONTemplate<SingleNode>>
declare type SingleNode = ChatiumBlockV2 | null | undefined | false | 0 | ''
declare type BoxAsyncProps = Omit<BoxProps, 'blocks'> & {
  blocks?: ChatiumChildNode[]
}
interface BoxBlock extends BoxProps {
  type: 'box'
}
interface BoxProps extends CommonBlockProps {
  style?: BlockStyle<BoxProps.Style>
  class?: BlockClass<'section' | 'absoluteFill'>
  onClick?: BlockActions
  onContext?: BlockActions
  blocks?: ChatiumBlockV2[]
}
declare namespace BoxProps {
  type Style = BoxStyle & BoxStateStyle
}
interface BoxStateStyle {
  active?: Pick<BoxStyle, 'backgroundColor' | 'opacity'>
}
declare type BoxStyle = BorderStyle &
  BoxColorStyle &
  BoxPositionStyle &
  BoxSizingStyle &
  BoxOverflowStyle &
  BoxPointerEventsStyle &
  FlexStyle &
  MarginStyle &
  PaddingStyle &
  TransformStyle &
  ShadowStyle
interface IconBlock extends IconProps {
  type: 'icon'
}
interface IconProps extends CommonIconProps {
  style?: BlockStyle<IconProps.Style>
  name: BlockProperty<PlainIconName>
}
declare namespace IconProps {
  type Style = IconStyle & CommonIconStateStyle
}
declare type PlainIconName = string | [IconFamily, string] | ['spinner', SpinnerName] | ['system', SystemIconName]
declare type IconFamily = 'fab' | 'far' | 'fas'
declare type IconStyle = CommonIconStyle & {
  color?: Color
}
declare type SpinnerName =
  | 'plane'
  | 'chase'
  | 'bounce'
  | 'wave'
  | 'pulse'
  | 'flow'
  | 'swing'
  | 'circle'
  | 'circle-fade'
  | 'grid'
  | 'fold'
  | 'wander'
declare type SystemIconName =
  | 'android-back'
  | 'close'
  | 'dots'
  | 'fast-forward-10'
  | 'fullscreen'
  | 'fullscreen-exit'
  | 'ios-back'
  | 'pause'
  | 'play-arrow'
  | 'replay'
  | 'rewind-10'
  | 'settings'
interface CommonIconProps extends CommonBlockProps {
  size?: BlockProperty<IconSize>
  onClick?: BlockActions
  onContext?: BlockActions
}
declare type IconSize = IconSizePreset | number
declare type IconSizePreset = 'sm' | 'md' | 'lg' | 'xl' | '2xl'
declare type CommonIconStyle = BorderStyle &
  SimpleBgColorStyle &
  ShadowStyle &
  BoxPositionStyle &
  MarginStyle &
  PaddingStyle &
  SelfAlignFlexStyle &
  TransformStyle
interface CommonIconStateStyle {
  active?: Pick<IconStyle, 'backgroundColor' | 'opacity'>
}
interface ButtonBlock extends ButtonProps {
  type: 'button'
}
interface ButtonAsyncProps extends Omit<ButtonProps, 'backgroundBlocks' | 'title'> {
  backgroundBlocks?: ChatiumChildNode[]
  title?: SingleOrArray<PlainOrPromise<ChatiumBlockV2> | string | number> | string | number
}
interface ButtonProps extends CommonBlockProps {
  title?: SingleOrArray<TextOrBlock>
  class?: BlockClass<ButtonClass>
  style?: BlockStyle<ButtonProps.Style>
  progressIcon?: Partial<IconProps>
  backgroundBlocks?: ChatiumBlockV2[]
  leftIcon?: IconProps
  rightIcon?: IconProps
  onClick?: BlockActions
  onContext?: BlockActions
}
declare namespace ButtonProps {
  type Style = ButtonStyle & ButtonStateStyle
}
interface ButtonStateStyle {
  active?: Pick<ButtonStyle, 'backgroundColor' | 'color' | 'opacity'>
}
declare type ButtonStyle = BoxStyle & TextStyle
declare type ButtonClass =
  | 'section'
  | 'primary'
  | 'secondary'
  | 'success'
  | 'danger'
  | 'warning'
  | 'info'
  | 'light'
  | 'dark'
  | 'link'
interface FooterAsyncProps extends Omit<FooterProps, 'blocks'> {
  blocks?: ChatiumChildNode[]
}
interface FooterBlock extends FooterProps {
  type: 'footer'
}
interface FooterProps extends Omit<BoxProps, 'style' | 'class'> {
  style?: BlockStyle<FooterProps.Style>
  class?: BlockClass<'standard'>
  stickToKeyboard?: BlockProperty<boolean>
  disableSafeAreaPadding?: BlockProperty<boolean>
}
declare namespace FooterProps {
  type Style = FooterStyle & BoxStateStyle
}
declare type FooterStyle = BorderStyle &
  ShadowStyle &
  BoxColorStyle &
  Pick<BoxSizingStyle, 'height' | 'maxHeight' | 'minHeight'> &
  FlexContainerStyle &
  Pick<MarginStyle, 'marginHorizontal' | 'marginLeft' | 'marginRight' | 'marginTop'> &
  PaddingStyle
interface HeaderBlock extends HeaderProps {
  type: 'header'
}
interface HeaderAsyncProps extends Omit<HeaderProps, 'title' | 'subTitle'> {
  title?: SingleOrArray<PlainOrPromise<ChatiumBlockV2>> | string | number
  subTitle?: PlainOrPromise<TextOrBlock>
}
interface HeaderProps extends CommonBlockProps {
  mode?: BlockProperty<'opaque' | 'parallax' | 'transparent' | 'disabled'>
  style?: BlockStyle<HeaderProps.Style>
  transparentStyle?: BlockStyle<BoxColorStyle & ColorStyle>
  title?: SingleOrArray<TextOrBlock>
  subTitle?: TextOrBlock
  leftOnClick?: BlockActions
  leftGoBackButton?: ButtonProps
  rightButton?: ButtonProps
}
declare namespace HeaderProps {
  type Style = BoxColorStyle & TextStyle & ShadowStyle
}
interface HiddenInputBlock extends HiddenInputProps {
  type: 'hidden-input'
}
interface HiddenInputProps extends CommonBlockProps {
  formId?: BlockProperty<string>
  name: BlockProperty<string>
  disabled?: BlockProperty<boolean>
  initialValue?: BlockProperty<unknown>
}
declare type TextChildNode = JSONTemplate<string | number | null | undefined | false | TextBlock>
interface TextBlock extends RequiredTextProps {
  type: 'text'
}
interface TextProps extends CommonBlockProps {
  class?: BlockClass<TextClass>
  style?: BlockStyle<TextProps.Style>
  text?: TextChildNode | Array<TextChildNode>
  onClick?: BlockActions
  onContext?: BlockActions
}
declare namespace TextProps {
  type Style = TextBlockStyle & TextStateStyle
}
interface TextStateStyle {
  active?: Pick<TextBlockStyle, 'backgroundColor' | 'color' | 'opacity'>
}
declare type TextBlockStyle = TextStyle &
  BorderStyle &
  BoxPositionStyle &
  BoxSizingStyle &
  MarginStyle &
  PaddingStyle &
  SelfAlignFlexStyle &
  SelfFlexStyle &
  SimpleBgColorStyle &
  ShadowStyle
declare type InnerText = string | number | RequiredTextProps
interface RequiredTextProps extends Omit<TextProps, 'text'>, Required<Pick<TextProps, 'text'>> {}
declare type TextClass =
  | 'section'
  | 'link'
  | 'badge'
  | 'listItemRightMiniText'
  | 'listItemSubTitle'
  | 'buttonTitle'
  | 'screenHeader'
interface HorizontalScrollAsyncProps extends Omit<HorizontalScrollProps, 'blocks'> {
  blocks?: ChatiumChildNode[]
}
interface HorizontalScrollBlock extends HorizontalScrollProps {
  type: 'horizontal-scroll'
}
interface HorizontalScrollProps extends CommonBlockProps {
  class?: BlockClass<HorizontalScrollClasses>
  style?: BlockStyle<HorizontalScrollProps.Style>
  snapToBlocks?: BlockProperty<boolean>
  showScrollBar?: BlockProperty<boolean>
  initialSlideIndex?: BlockProperty<number>
  blocks?: ChatiumBlockV2[]
}
declare namespace HorizontalScrollProps {
  type Style = HorizontalScrollStyle
}
declare type HorizontalScrollClasses = 'section'
declare type HorizontalScrollStyle = BorderStyle & MarginStyle & SimpleBgColorStyle & PaddingStyle
declare type HorizontalScrollIndicatorProps = PositionIndicatorDotsAsync | PositionIndicatorTextProps
declare type HorizontalScrollIndicatorBlock = {
  type: 'horizontal-scroll-indicator'
} & CommonBlockProps &
  (PositionIndicatorDotsProps | PositionIndicatorTextProps)
interface PositionIndicatorCommonProps {
  position?: 'top-left' | 'top-center' | 'top-right' | 'bottom-right' | 'bottom-center' | 'bottom-left'
}
interface PositionIndicatorDotsAsync extends Omit<PositionIndicatorDotsProps, 'inactiveDot' | 'activeDot'> {
  inactiveDot?: ChatiumChildNode
  activeDot?: ChatiumChildNode
}
interface PositionIndicatorDotsProps extends PositionIndicatorCommonProps {
  indicator: 'dots'
  style?: PositionIndicatorDotsStyle
  inactiveDot?: ChatiumBlockV2
  activeDot?: ChatiumBlockV2
}
declare type PositionIndicatorDotsStyle = MarginStyle &
  SimpleBgColorStyle &
  BackgroundGradientStyle &
  ShadowStyle &
  PaddingStyle &
  BoxSizingWidthStyle &
  BorderStyle
interface PositionIndicatorTextProps extends PositionIndicatorCommonProps {
  indicator: 'text'
  style?: PositionIndicatorTextStyle
  text?: TextChildNode | Array<TextChildNode>
}
declare type PositionIndicatorTextStyle = MarginStyle &
  SimpleBgColorStyle &
  BackgroundGradientStyle &
  ShadowStyle &
  PaddingStyle &
  BoxSizingWidthStyle &
  BorderStyle &
  TextStyle
interface IAPProductProps extends CommonBlockProps {
  productId: SingleOrArray<string | ProductDefinition>
  productTemplate: SingleOrArray<ChatiumBlockV2>
  loadingContent?: SingleOrArray<ChatiumBlockV2> | void
  errorContent?: SingleOrArray<ChatiumBlockV2> | void
  style?: BlockStyle<IAPProductProps.Style>
  class?: BoxProps['class']
  onClick?: BoxProps['onClick']
  onContext?: BoxProps['onContext']
}
declare namespace IAPProductProps {
  type Style = BoxProps.Style
}
interface ProductDefinition {
  id: string
  googlePlayOfferTags?: string[]
  googlePlayBasePlanId?: string
  googlePlayOfferId?: string
}
interface IAPProductBlock extends IAPProductProps {
  type: 'iap-product'
}
interface IAPProductAsyncProps extends Omit<IAPProductProps, 'productTemplate' | 'loadingContent' | 'errorContent'> {
  productTemplate?: SingleOrArray<ChatiumChildNode>
  loadingContent?: SingleOrArray<ChatiumChildNode>
  errorContent?: SingleOrArray<ChatiumChildNode>
}
interface ImageBlock extends ImageProps {
  type: 'image'
}
interface ImageProps extends CommonBlockProps {
  src: BlockProperty<{
    url: string
    width?: number
    height?: number
  }>
  resizeMode?: BlockProperty<'stretch' | 'contain' | 'cover'>
  class?: BlockClass<'section' | 'absoluteFill'>
  style?: BlockStyle<ImageProps.Style>
  onClick?: BlockActions
  onContext?: BlockActions
}
declare namespace ImageProps {
  type Style = ImageStyle & ImageStateStyle
}
interface ImageStateStyle {
  active?: Pick<ImageStyle, 'backgroundColor' | 'opacity'>
}
declare type ImageStyle = BoxPositionStyle &
  BoxSizingStyle &
  MarginStyle &
  ImageAlignSelfStyle &
  SelfFlexStyle &
  BoxColorStyle &
  BorderStyle &
  ShadowStyle
interface ImageAlignSelfStyle {
  alignSelf?: 'auto' | 'flex-start' | 'flex-end' | 'center' | 'baseline'
}
interface SmartIconBlock extends SmartIconProps {
  type: 'smart-icon'
}
interface SmartIconProps extends CommonIconProps {
  class?: BlockClass<'circle' | 'square'>
  style?: BlockStyle<SmartIconProps.Style>
  name?: IconProps['name']
  url?: BlockProperty<string>
  text?: BlockProperty<string | number>
  /**
   * Small icons or text-badges positioned at the corners of this icon
   */
  badges?: SingleOrArray<SubIcon | SmartIconBadgeProps>
}
declare namespace SmartIconProps {
  type Style = SmartIconStyle & CommonIconStateStyle
}
interface IconScaleStyle {
  iconScale?: number
}
declare type SmartIconStyle = CommonIconStyle & BackgroundGradientStyle & IconTextStyle & IconScaleStyle
interface SubIcon extends Omit<SmartIconProps, 'badges' | 'style' | 'onClick' | 'onContext'> {
  style?: BlockStyle<SubIconStyle>
  position?: BlockProperty<BadgePosition>
}
declare type SubIconStyle = BorderStyle &
  BoxColorStyle &
  Omit<BoxPositionStyle, 'position'> &
  IconTextStyle &
  PaddingStyle &
  TransformStyle &
  IconScaleStyle &
  ShadowStyle
interface SmartIconBadgeProps {
  badge: BlockProperty<string | number>
  style?: BlockStyle<SmartIconBadgeStyle>
  position?: BlockProperty<BadgePosition>
}
declare type SmartIconBadgeStyle = IconTextStyle &
  BorderStyle &
  SimpleBgColorStyle &
  Omit<BoxPositionStyle, 'position'> &
  BoxSizingStyle &
  PaddingStyle &
  TransformStyle
declare type BadgePosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'custom'
declare type IconTextStyle = {
  color?: TextStyle['color']
  fontSize?: TextStyle['fontSize']
  fontStyle?: TextStyle['fontStyle']
  fontWeight?: TextStyle['fontWeight']
  fontVariant?: TextStyle['fontVariant']
  letterSpacing?: TextStyle['letterSpacing']
  textDecorationLine?: TextStyle['textDecorationLine']
  textShadowColor?: TextStyle['textShadowColor']
  textShadowOffset?: TextStyle['textShadowOffset']
  textShadowRadius?: TextStyle['textShadowRadius']
  textTransform?: TextStyle['textTransform']
}
interface ListItemBlock extends ListItemProps {
  type: 'list-item'
}
interface ListItemAsyncProps extends Omit<ListItemProps, 'content' | 'customContent'> {
  content?: {
    title?: PlainOrPromise<TextOrBlock>
    rightMiniText?: PlainOrPromise<TextOrBlock>
    subTitle?: PlainOrPromise<TextOrBlock>
    badge?: string | number | ListItemBadgeProps
  }
  customContent?: JSONTemplate<SingleOrArray<ChatiumChildNode>>
}
interface ListItemProps extends CommonBlockProps {
  icon?: SmartIconProps
  content?: {
    title?: TextOrBlock
    rightMiniText?: TextOrBlock
    subTitle?: TextOrBlock
    badge?: ListItemBadgeProps | TextOrBlock
  }
  class?: BlockClass<ListItemClass>
  style?: BlockStyle<ListItemProps.Style>
  customContent?: SingleOrArray<ChatiumBlockV2>
  onClick?: BlockActions
  /**
   * Long tap - on mobile
   * Right click - on desktop
   */
  onContext?: BlockActions
  /**
   * Defines buttons and corresponding actions that appear when
   *  swiping the list item left or right (on mobile device)
   *  or hovering and context menu (on desktop)
   * To achieve smooth cross-platform behavior
   *  for every button developer should define at least two `on` actions: one - for mobile and one - for desktop.
   */
  actionButtons?: SingleOrArray<ActionButtonProps>
}
declare namespace ListItemProps {
  type Style = ListItemStyle & ListItemStateStyle
}
interface ListItemStateStyle {
  active?: Pick<ListItemStyle, 'backgroundColor' | 'color' | 'opacity'>
}
declare type ListItemClass = 'muted' | 'selected'
declare type ListItemStyle = BorderStyle &
  BoxColorStyle &
  BoxSizingStyle &
  FlexStyle &
  MarginStyle &
  PaddingStyle &
  TextStyle &
  TransformStyle &
  ShadowStyle
interface ListItemBadgeProps {
  badge: string | number
  style?: BlockStyle<ListItemBadgeStyle>
}
declare type ListItemBadgeStyle = IconTextStyle &
  BorderStyle &
  BoxPositionStyle &
  BoxSizingStyle &
  MarginStyle &
  PaddingStyle &
  SelfAlignFlexStyle &
  SelfFlexStyle &
  SimpleBgColorStyle &
  TransformStyle
interface ActionButtonProps {
  on: SingleOrArray<ListItemActionType>
  class?: SingleOrArray<'reset' | 'danger' | 'warn' | 'success'>
  style?: SingleOrArray<BoxColorStyle & PaddingStyle & TextStyle>
  title?: InnerText
  icon?: IconProps
  onClick?: ChatiumActions
}
declare type ListItemActionType = 'swipe-left' | 'swipe-right' | 'hover' | 'web-context'
interface ParallaxAsyncProps extends Omit<ParallaxProps, 'background' | 'content'> {
  background?: SingleOrArray<ChatiumChildNode> | ImageProps
  content?: SingleOrArray<ChatiumChildNode>
}
interface ParallaxBlock extends ParallaxProps {
  type: 'parallax'
}
interface ParallaxProps extends CommonBlockProps {
  style?: BlockStyle<ParallaxProps.Style>
  contentStyle?: BlockStyle<ContentStyle>
  background?: SingleOrArray<ChatiumBlockV2>
  content?: SingleOrArray<ChatiumBlockV2>
  onClick?: BlockActions
  onContext?: BlockActions
}
declare namespace ParallaxProps {
  type Style = MarginStyle & ShadowStyle
}
declare type ContentStyle = FlexContainerStyle & PaddingStyle & BorderStyleNoRadius & BoxColorStyle
interface SliderBlock extends SliderProps {
  type: 'slider'
}
interface SliderProps extends CommonBlockProps {
  name?: BlockProperty<string>
  formId?: BlockProperty<string>
  disabled?: BlockProperty<boolean>
  class?: BlockClass<SliderClass>
  style?: BlockStyle<SliderStyle>
  trackStyle?: BlockStyle<SliderTrackStyle>
  thumb?: SliderThumbProps
  initialValue?: BlockProperty<number>
  value?: BlockProperty<number>
  minValue?: BlockProperty<number>
  maxValue?: BlockProperty<number>
  step?: BlockProperty<number>
  onChange?: BlockActions
  onDrag?: BlockActions
  disableErrorHint?: BlockProperty<boolean>
}
declare type SliderThumbProps = {
  style?: BlockStyle<SliderThumbStyle>
  imageUrl?: BlockProperty<string>
}
declare type SliderClass = 'section'
declare type SliderStyle = BorderStyle &
  BoxPositionStyle &
  BoxSizingStyle &
  FlexStyle &
  MarginStyle &
  PaddingStyle &
  ShadowStyle &
  BackgroundColorStyle &
  OpacityStyle
declare type SliderTrackStyle = BoxSizingHeightStyle &
  BorderStyle & {
    leftColor?: Color
    rightColor?: Color
  }
declare type SliderThumbPlainStyle = BorderStyle & BoxSizingStyle & ShadowStyle & BackgroundColorStyle & OpacityStyle
declare type SliderThumbStyle = SliderThumbPlainStyle & {
  active?: SliderThumbPlainStyle
}
interface RunActionIntervalBlock extends RunActionIntervalProps {
  type: 'run-action-interval'
}
interface RunActionIntervalProps extends CommonBlockProps {
  interval: number
  action: BlockActions
}
declare type StickyAsyncProps = Omit<StickyProps, 'blocks'>
interface StickyBlock extends StickyProps {
  type: 'sticky'
}
interface StickyProps extends BoxProps {
  style?: BlockStyle<StickyProps.Style>
}
declare namespace StickyProps {
  type Style = StickyStyle & BoxStateStyle
}
declare type StickyStyle = BorderStyle &
  ShadowStyle &
  BoxColorStyle &
  BoxSizingStyle &
  BoxOverflowStyle &
  FlexStyle &
  MarginStyle &
  PaddingStyle
interface TextInputBlock extends TextInputProps {
  type: 'text-input'
}
interface SearchInputBlock extends SearchInputProps {
  type: 'search-input'
}
interface TextInputProps extends CommonInputProps {
  class?: BlockClass<'section'>
  style?: BlockStyle<TextInputProps.Style>
  initialValue?: BlockProperty<string>
  placeholder?: BlockProperty<string>
  multiline?: BlockProperty<boolean>
  inputmode?: BlockProperty<'text' | 'decimal' | 'tel' | 'email' | 'url' | 'password'>
  autoFocus?: BlockProperty<boolean>
  autoCorrect?: BlockProperty<boolean>
  returnKeyType?: BlockProperty<'done' | 'go' | 'next' | 'search' | 'send'>
  onReturnKeyPress?: BlockProperty<InputOnChangeAction>
  autocapitalize?: BlockProperty<'none' | 'sentences' | 'words' | 'characters'>
  maxLength?: BlockProperty<number>
  sendHashed?:
    | boolean
    | {
        salt: string
      }
  disableErrorHint?: BlockProperty<boolean>
  blocks?: ChatiumBlockV2[]
}
declare namespace TextInputProps {
  type Style = TextInputStyle | TextInputStateStyle
}
declare type TextInputSizingStyle = {
  width?: BoxSizingStyle['width']
  maxWidth?: BoxSizingStyle['maxWidth']
  minWidth?: BoxSizingStyle['minWidth']
}
declare type TextInputTextStyle = Omit<TextStyle, 'textAlignVertical'>
declare type TextInputStyle = BorderStyle &
  ShadowStyle &
  BoxColorStyle &
  BoxPositionStyle &
  TextInputSizingStyle &
  MarginStyle &
  PaddingStyle &
  TextInputTextStyle &
  SelfAlignFlexStyle &
  SelfFlexStyle
interface TextInputStateStyle {
  disabled?: TextInputStyle
  focus?: TextInputStyle
  valid?: TextInputStyle
  invalid?: TextInputStyle
}
declare type InputOnChangeAction = string | Pick<SubmitFormAction, 'url' | 'params'> | BlockActions
interface CommonInputProps extends CommonBlockProps {
  formId?: BlockProperty<string>
  name: BlockProperty<string>
  disabled?: BlockProperty<boolean>
  debounceOnChangeMs?: BlockProperty<number>
  onChange?: InputOnChangeAction
  onContext?: BlockActions
}
interface SearchInputProps extends CommonInputProps {
  class?: BlockClass<'section'>
  style?: BlockStyle<SearchInputProps.Style>
  initialValue?: BlockProperty<string>
  placeholder?: BlockProperty<string>
}
declare namespace SearchInputProps {
  type Style = TextInputStyle | TextInputStateStyle
}
interface TextInputIndicatorProps {
  style?: TextInputIndicatorStyle
  text?: TextChildNode | Array<TextChildNode>
}
declare type TextInputIndicatorBlock = {
  type: 'text-input-indicator'
} & CommonBlockProps &
  TextInputIndicatorProps
declare type TextInputIndicatorStyle = BoxPositionStyle &
  MarginStyle &
  SimpleBgColorStyle &
  BackgroundGradientStyle &
  ShadowStyle &
  PaddingStyle &
  BoxSizingWidthStyle &
  BorderStyle &
  TextStyle
interface VideoBlock extends VideoProps {
  type: 'video'
}
interface VideoProps extends Omit<VideoPlayerProps, 'src'>, CommonBlockProps {
  src: VideoPlayerProps['src'] | VideoYoutubeSrcProps
  class?: BlockClass<'section' | 'absoluteFill'>
  style?: BlockStyle<VideoProps.Style>
  poster?: BlockProperty<string>
  resizeMode?: BlockProperty<'stretch' | 'contain' | 'cover'>
  onContext?: BlockActions
}
declare namespace VideoProps {
  type Style = VideoStyle
}
declare type VideoStyle = BorderStyle &
  ShadowStyle &
  BoxColorStyle &
  BoxPositionStyle &
  BoxSizingStyle &
  MarginStyle &
  SelfAlignFlexStyle &
  SelfFlexStyle
interface VideoPosterBlock extends VideoPosterProps {
  type: 'video-poster'
}
interface VideoPosterProps extends CommonBlockProps {
  src: ImageProps['src']
  resizeMode?: ImageProps['resizeMode']
  icon?: Pick<IconProps, 'name' | 'size' | 'style'>
  video?: Omit<ShowVideoAction, 'type'>
  class?: BlockClass<'section' | 'absoluteFill'>
  style?: BlockStyle<VideoPosterProps.Style>
  onContext?: ChatiumActions
}
declare namespace VideoPosterProps {
  type Style = VideoStyle
}
interface ShowVideoAction {
  type: 'showVideo'
  src: VideoPlayerProps['src']
  preferredQuality?: VideoPlayerProps['preferredQuality']
  onVideoEnd?: VideoPlayerProps['onVideoEnd']
}
interface VideoPlayerProps {
  src:
    | {
        hls?: string
        mp4: string
        width?: number
        height?: number
      }
    | {
        hls: string
        mp4?: string
        width?: number
        height?: number
      }
  preferredQuality?: number
  autoplay?: boolean
  loop?: boolean
  muted?: boolean
  onVideoEnd?: ChatiumActions
  controls?: 'full' | 'compact' | 'mini' | 'none'
  ignoreSilentSwitch?: boolean
  playInBackground?: boolean
  playWhenInactive?: boolean
}
interface VideoYoutubeSrcProps {
  youtubeId: string
  width?: number
  height?: number
}
declare type BlocksUnion =
  | AudioBlock
  | BoxBlock
  | ButtonBlock
  | FooterBlock
  | HeaderBlock
  | HorizontalScrollBlock
  | HorizontalScrollIndicatorBlock
  | IAPProductBlock
  | IconBlock
  | ImageBlock
  | ListItemBlock
  | ParallaxBlock
  | SearchInputBlock
  | SmartIconBlock
  | StickyBlock
  | TextBlock
  | TextInputBlock
  | HiddenInputBlock
  | TextInputIndicatorBlock
  | VideoBlock
  | VideoPosterBlock
  | SliderBlock
  | RunActionIntervalBlock
declare type ChatiumBlockV2 = BlocksUnion | JSONTemplate<BlocksUnion | Array<ChatiumBlockV2>>
declare type DynVar = string | number | boolean
declare type TranslationKey<T extends string = string> = [T, StaticTranslateArgs | undefined]
declare type TranslateArgs = {
  [key: string]: DynVar | InCodeSelector | bigint
} & {
  $ns?: string
}
declare type StaticTranslateArgs = {
  [key: string]: StaticInCodeSelector | string
} & {
  $ns?: string
}
declare type DynamicTranslateArgs = {
  [key: string]: DynVar
}
declare type InCodeSelector = {
  $val?: DynVar
} & StaticInCodeSelector
declare type StaticInCodeSelector = {
  $pluralType?: Intl.PluralRulesOptions['type']
  $other?: string | number
} & Record<string | number, DynVar>
declare type Lang = string
interface LangCtx {
  lang: Lang
}
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
declare type WebOrUgcHook<P, R> = string & {
  p: P
  r: R
}
interface MetricEventRecord {
  sign?: number
  uid?: string
  sid?: string
  sid_duration?: number
  inferred_uid?: boolean
  inferred_sid?: boolean
  gc_visit_id?: number
  gc_visitor_id?: number
  gc_session_id?: number
  account_id: number
  account_type: AccountType
  url: string
  referer?: string
  user_agent?: string
  ip?: string
  title?: string
  screen_width?: number
  screen_height?: number
  screen_pixel_ratio?: number
  location_country?: string
  location_region?: string
  location_time_zone?: string
  location_city?: string
  location_coordinates_latitude?: number
  location_coordinates_longitude?: number
  ua_client_type?: string
  ua_client_name?: string
  ua_client_version?: string
  ua_device_type?: string
  ua_device_brand?: string
  ua_device_model?: string
  ua_os_name?: string
  ua_os_version?: string
  ua_os_platform?: string
  ua_bot_name?: string
  ua_bot_category?: string
  os_name?: string
  device_name?: string
  request_type: 'screen' | 'apiCall' | 'get' | 'post'
  auth_id?: number
  auth_type?: string
  auth_key?: string
  auth_first_name?: string
  auth_last_name?: string
  auth_lang?: string
  user_id?: string
  user_type?: 'Anonymous' | 'Real' | 'Bot'
  user_roles?: string[]
  user_account_role?: string
  user_status?: string
  user_expires_at?: Date | null
  user_first_name?: string
  user_last_name?: string
  user_icon_image?: string
  user_phone?: string
  user_email?: string
  user_platforms?: string[]
  session_id?: string
  session_email?: string
  session_phone?: string
  fcm_token?: string
  ts: Date
  ts64?: number
  funnel?: string
  funnel_node?: string
  funnel_node_from?: string
  utm_source?: string
  utm_content?: string
  utm_medium?: string
  utm_campaign?: string
  utm_term?: string
  action?: string
  action_params?: string
  action_param1?: string
  action_param2?: string
  action_param3?: string
  action_param1_float?: number
  action_param2_float?: number
  action_param3_float?: number
  action_param4_float?: number
  action_param1_int?: number
  action_param2_int?: number
  action_param3_int?: number
  action_param1_arrstr?: string[]
  action_param2_arrstr?: string[]
  action_param3_arrstr?: string[]
  action_param1_uint32arr?: number[] | undefined
  keys?: string[]
  values?: string[]
  /**
   * CLRT parsing
   * clrt=t:y_c:{campaign_id}_g:{gbid}_a:{ad_id}_ph:{phrase_id}_k:{keyword}_cr:{creative_id}_rt:{retargeting_id}_int:{interest_id}_at:{adtarget_id}_reg:{region_id}_s:{source}_dt:{device_type}
   */
  param_clrt?: string
  clrt_type?: string
  clrt_campaign_id?: string
  clrt_ad_id?: string
}
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare class HeapRecordHelperClass {
  id: HeapId
  idx: number
  account_id: number
  type: HeapObjectType
  data: object | null
  created_by: HeapId | null | undefined
  created_at: Date
  updated_by: HeapId | null | undefined
  updated_at: Date
  constructor(
    id: HeapId,
    idx: number,
    account_id: number,
    type: HeapObjectType,
    data: object | null,
    created_by: HeapId | null | undefined,
    created_at: Date,
    updated_by: HeapId | null | undefined,
    updated_at: Date,
  )
}
declare type HeapRecord = PublicFieldsOfClass<HeapRecordHelperClass>
interface HeapObjectBase {
  id: HeapId
  idx: number
  heapType: HeapObjectType
  createdAt: Date
  updatedAt: Date
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObject<HD extends HeapData> = HeapObjectBase & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
declare type HeapId = string
declare type HeapObjectType = string
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
interface FileClass {
  new (hash: string): IStorageFile
}
interface IStorageFile {
  hash: string
  type: HashMediaType
  downloadUrl: string
  toJSON(): string
}
interface IStorageFileWithSizes extends IStorageFile {
  width: number
  widthMaybe: number | undefined
  height: number
  heightMaybe: number | undefined
  sizes: {
    width: number
    height: number
  }
  sizesMaybe:
    | {
        width: number
        height: number
      }
    | undefined
}
interface ImageFileClass {
  new (hash: string): IStorageImageFile
}
interface IStorageImageFile extends IStorageFileWithSizes {
  getThumbnailUrl(width?: number, height?: number): string
  getThumbnailSrc(width?: number, height?: number): ImageBlock['src']
}
interface VideoFileClass {
  new (hash: string): IStorageVideoFile
}
interface IStorageVideoFile extends IStorageFileWithSizes {
  duration: number
  durationMaybe: number | undefined
  videoSrc: Promise<VideoBlock['src']>
  status: Promise<'done' | 'processing' | 'error'>
  progress: Promise<number>
  getThumbnailUrl(width?: number, height?: number, offsetSeconds?: 'auto' | number): string
  getThumbnailSrc(width?: number, height?: number, offsetSeconds?: 'auto' | number): ImageBlock['src']
}
interface AudioFileClass {
  new (hash: string): IStorageAudioFile
}
interface IStorageAudioFile extends IStorageFile {
  duration: number
  durationMaybe: number | undefined
  audioSrc: AudioBlock['src']
}
interface HeapRuntimeClasses {
  RefLinkClass: RefLinkClass
  GenericLinkClass: GenericLinkClass
  FileClass: FileClass
  ImageFileClass: ImageFileClass
  VideoFileClass: VideoFileClass
  AudioFileClass: AudioFileClass
}
declare type HeapLinkInfo =
  | {
      refType: 'RefLink'
      fieldPath: string
      targetType: HeapObjectType
      id: HeapId
    }
  | {
      refType: 'GenericLink'
      fieldPath: string
      id: HeapId
    }
  | {
      fieldPath: string
      id: null
    }
interface HeapTableRecordApi<ReadCtx, WriteCtx> {
  findHeapRecordByTypeAndId(ctx: ReadCtx, type: HeapObjectType, id: HeapId): Promise<HeapRecord | null>
  findHeapRecordsByTypeAndIds(ctx: ReadCtx, type: HeapObjectType, ids: HeapId[]): Promise<HeapRecord[]>
  queryHeapRecords<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    options?: HeapRecordSelectOptions<HSP>,
  ): Promise<HeapRecord[]>
  queryHeapRecordIds<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    options?: HeapRecordSelectOptions<HSP>,
  ): Promise<HeapId[]>
  countHeapRecords<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    filter?: HeapRecordFilter<HSP> | null,
  ): Promise<number>
  createHeapRecord<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    linkInfo: HeapLinkInfo[],
    data: Static<HsObject<HSP>> & {
      id?: HeapId
    },
  ): Promise<HeapRecord>
  updateHeapRecordMaybe<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    linkInfo: HeapLinkInfo[],
    patch: Partial<Static<HsObject<HSP>>> & {
      id: HeapId
    },
    optionalFieldsToClear?: Array<keyof HSP>,
  ): Promise<HeapRecord | null>
  createOrUpdateHeapRecordBy<HSP extends HsProperties, K extends HsProperty<HSP>>(
    ctx: WriteCtx,
    type: HeapObjectType,
    uniqKey: K,
    linkInfo: HeapLinkInfo[],
    data: Static<HsObject<HSP>>,
  ): Promise<HeapRecord>
  deleteHeapRecord(ctx: WriteCtx, type: HeapObjectType, id: HeapId, hardDelete: boolean): Promise<HeapRecord | null>
  createOrUpdateSingleton<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    createLinkInfo: HeapLinkInfo[],
    createData: Static<HsObject<HSP>>,
    updateLinkInfo: HeapLinkInfo[],
    updatePatch: Partial<Static<HsObject<HSP>>>,
    optionalFieldsToClear?: Array<keyof HSP>,
  ): Promise<HeapRecord>
}
declare type HsSelectOptions<HSP extends HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HeapOrderByV2<HSP> | null | undefined
}
declare type HsFilter<HSP extends HsProperties> =
  | HsFilterInputObject<HSP & Pick<HeapObjectBaseSchema, 'id' | 'createdAt' | 'updatedAt' | 'createdBy' | 'updatedBy'>>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTopAndOperator<HSP extends HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends HeapSchema> = HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare abstract class ReadOnlyHeapTableRepo<HSP extends hs.HsProperties, ReadCtx, WriteCtx = ReadCtx> {
  readonly type: HeapObjectType
  protected readonly tableOptions?: HeapTableOptions<HSP> | undefined
  readonly schema: hs.HsObject<HSP>
  readonly T: hs.HsFullObjectRuntime<HSP>
  readonly JsonT: hs.HsObjectStatic<HSP>
  readonly PropsT: HSP
  readonly PatchT: Partial<hs.HsUpdateInputObject<HSP>>
  readonly CreateInputT: hs.HsCreateInputObject<HSP> & {
    id?: HeapId
  }
  /**
   * Low-level heap record API differs for core backend and UGC implementations
   * This helps to share a lot of high-level code written in this class for UGC/core implementations of the heap table
   */
  protected abstract recordApi: HeapTableRecordApi<ReadCtx, WriteCtx>
  /**
   * Runtime RefLink instance implementations differ for core backend and UGC in terms of
   *  how they implement .get() method, when only a string type repo is provided.
   *  Global registries of heap-table repos are organized differently
   */
  protected abstract runtimeClasses: HeapRuntimeClasses
  constructor(type: HeapObjectType, fields: hs.HsPropertiesNo$<HSP>, tableOptions?: HeapTableOptions<HSP> | undefined)
  /**
   * Type guard to easily recognize heap objects belonging to this table
   * May be useful in combination with generic links
   */
  isMyRecord(obj: unknown): obj is this['T']
  getById(ctx: ReadCtx, id: HeapId): Promise<this['T']>
  getRecordTitleById(ctx: ReadCtx, id: HeapId): Promise<string>
  /**
   * Generic method to get human-readable title of the record.
   * May be customized by tableOptions.getRecordTitleSync.
   * By default, it tries to use 'title' or 'name' fields, or just '#<id>'.
   */
  getRecordTitle(_ctx: ReadCtx, row: this['T']): Promise<string>
  findById(ctx: ReadCtx, id: HeapId): Promise<this['T'] | null>
  findByIds(ctx: ReadCtx, ids: HeapId[]): Promise<this['T'][]>
  findAll(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<this['T'][]>
  findAllIds(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<HeapId[]>
  findBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'][]>
  findOneBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'] | null>
  countBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<number>
  /**
   * Returns a singleton row of this table or a stub record with default values.
   * Treats the whole table as a single-row "singleton".
   * All fields of this table must be Heap.NonRequired, Heap.Nullable or Heap.Optional,
   *  or at least have a "default" option defined.
   */
  getSingleton(ctx: ReadCtx): Promise<this['T']>
  protected getDefaultSingleton(): this['T']
  protected rawToObject: (hr: HeapRecord) => this['T']
  get customMeta(): NonNullable<hs.HsCustomMetaOption['customMeta']>
  /**
   * Augments and converts where and order options according to the schema
   * DRY
   */
  private prepareSelectOptions
}
interface HeapTableOptions<HSP extends hs.HsProperties> extends hs.HsCustomMetaOption {
  getRecordTitleSync?(record: hs.HsFullObjectRuntime<HSP>): string | null | undefined
}
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends HsProperties = HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>)
  get<R = HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends HsProperties = HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare class AuthHelperClass {
  id: number
  type: AuthType
  key: string
  /**
   * List of account IDs which have this auth registered as a user
   * This field seems redundant because this info can be obtained from Users of each account,
   *   but as every account has its own heap DB, there is no easy way to iterate over accounts for the given auths
   *   without this field.
   */
  accounts: number[]
  avatar: Icon | null
  first_name: string | null
  last_name: string | null
  /**
   * Stores info about which session auth data was merged to which real auth.
   * This is a key for performant detecting when to migrate data without any additional db queries or computations.
   *
   * For type === Session -> map from <account ID> -> list of linked <real auth ID>s
   * For others           -> map from <account ID> -> list of linked <session auth KEY>s
   * @see mergeSessionToRealAuth
   * @see unlinkSessionAuth
   */
  session_links: Record<number, string[] | number[]>
  expires_at: Date | null
  constructor(
    id: number,
    type: AuthType,
    key: string,
    /**
     * List of account IDs which have this auth registered as a user
     * This field seems redundant because this info can be obtained from Users of each account,
     *   but as every account has its own heap DB, there is no easy way to iterate over accounts for the given auths
     *   without this field.
     */
    accounts: number[],
    avatar: Icon | null,
    first_name: string | null,
    last_name: string | null,
    /**
     * Stores info about which session auth data was merged to which real auth.
     * This is a key for performant detecting when to migrate data without any additional db queries or computations.
     *
     * For type === Session -> map from <account ID> -> list of linked <real auth ID>s
     * For others           -> map from <account ID> -> list of linked <session auth KEY>s
     * @see mergeSessionToRealAuth
     * @see unlinkSessionAuth
     */
    session_links: Record<number, string[] | number[]>,
    expires_at: Date | null,
  )
}
declare type Auth = PublicFieldsOfClass<AuthHelperClass>
declare enum AuthType {
  Email = 'Email',
  None = 'None',
  Phone = 'Phone',
  Session = 'Session',
  Inbox = 'Inbox',
  API = 'API',
}
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare type EntityId = string
declare type IdentityType =
  | CustomProvidableIdentityType
  | 'Password'
  | 'ApiKey'
  | 'ParentAccountUser'
  | 'DeviceId'
  | 'TechSupport'
  | 'GetcourseId'
declare type CustomProvidableIdentityType = 'Phone' | 'Email' | 'TelegramId'
declare type AuthProvider =
  | 'Device'
  | 'Sms'
  | 'Email'
  | 'Password'
  | 'AnotherSession'
  | 'ParentAccount'
  | 'Getcourse'
  | 'MobileAppPhone'
  | 'MobileAppEmail'
  | 'Github'
  | 'Google'
  | 'Telegram'
  | 'Chatium'
  | string
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type ExtendedUserFieldsSupport = Partial<Record<keyof ExtendedUserFields, boolean>>
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObject<UserData>
declare type UgcSystemHeapTableName = 'users'
interface MobileAppLinkPrefixes {
  bundleId: string
  custom?: string
  web?: string
}
declare type AuthProviderHook = {
  id: string
  /**
   * Returns basic information about the provider
   * Used auth provider preferences editor UI
   */
  getInfo(ctx: RichUgcCtx): Promise<AuthProviderInfo>
  /**
   * Should return a button that is shown on sign-in screen as an alternative authentication method
   */
  getAuthButton(ctx: RichUgcCtx, params: AuthFlowParams): Promise<AuthProviderButtonInfo | null | undefined>
}
interface AuthFlowParams {
  backUrl?: string
  fromApiCall?: boolean
  mobileAppLinkPrefixes?: MobileAppLinkPrefixes
}
interface AuthProviderButtonInfo {
  title: string
  onClick: ChatiumActions
  icon?: Pick<SmartIconProps, 'url' | 'name' | 'text' | 'class'> & {
    style?: BackgroundGradientStyle &
      BorderStyle &
      CommonIconStateStyle &
      IconScaleStyle &
      IconTextStyle &
      ShadowStyle &
      SimpleBgColorStyle
  }
}
interface AuthProviderInfo {
  id: AuthProvider
  title: string
  icon?: Pick<SmartIconProps, 'name' | 'url' | 'text'>
  settingsUrl?: string
}
declare type InitializerCtx = RichUgcCtx | ClientCtx
declare type ClientCtx = {
  t: RichUgcCtx['t']
  user: RichUgcCtx['user']
  account: {
    url(path: string): string
  }
  location: RichUgcCtx['location']
}
declare type AccountUrlFn = {
  accountUrlParams: AccountUrlParams
  (path: string, options?: QueryParamsOption): string
}
interface AccountUrlParams {
  accountName: string
  accountHost: string
  accountPathPrefix: string
  pluginAppInfo?: UgcPluginAppUrlInfo
}
declare type RouteRunCtx = InitializerCtx
interface HttpRouteRef {
  readonly routerUrlPath: string
  readonly pattern: string
  readonly needParams: boolean | null
  (params: Record<string, string | number> | string | number): this
  query(queryParams: JSONInputObject): this
  path(): string
  url(): string
}
declare type RouteRefHandlerFn = (url: string, ctx: RichUgcCtx, req: UgcRouteParsedRequest) => any
declare type RouteRefRunResult<T> = T extends Promise<any> ? T : Promise<T>
interface PostRouteRef<Body = any, Result = any> extends HttpRouteRef {
  run(ctx: RouteRunCtx, body: Body): RouteRefRunResult<Result>
}
declare function PostRouteRef(
  pattern: string,
  handlerFn: RouteRefHandlerFn,
  needParams: boolean | null,
  routerUrlPath: string | null,
  accountUrl: AccountUrlFn,
): PostRouteRef
interface GetRouteRef<Result = any> extends HttpRouteRef {
  navigate(options?: Parameters<typeof navigate>[1]): NavigateAction
  run(ctx: InitializerCtx): RouteRefRunResult<Result>
}
declare function GetRouteRef(
  pattern: string,
  handlerFn: RouteRefHandlerFn,
  needParams: boolean | null,
  routerUrlPath: string | null,
  accountUrl: AccountUrlFn,
): GetRouteRef
interface ApiCallRouteRef<Body = any, Result = any> extends PostRouteRef<Body, Result> {
  apiCall(apiParams?: Parameters<typeof apiCall>[1], options?: Parameters<typeof apiCall>[2]): ApiCallAction
}
declare function ApiCallRouteRef(
  pattern: string,
  handlerFn: RouteRefHandlerFn,
  needParams: boolean | null,
  routerUrlPath: string | null,
  accountUrl: AccountUrlFn,
): ApiCallRouteRef
declare class JobRouteRef<P extends JSONInputValue | undefined, R extends JSONInputValue | void> {
  readonly pattern: string
  private readonly accountUrl
  readonly routerUrlPath: string
  constructor(pattern: string, routerUrlPath: string | null, accountUrl: AccountUrlFn)
  path(): WebOrUgcHook<P, R>
}
declare class UgcHttpResponseTuner {
  #private
  statusCode: number | undefined
  simplifiedContentType: SimplifiedContentType
  setHeader(name: string, value: string): this
  getHeader(name: string): string | undefined
  hasHeader(name: string): boolean
  removeHeader(name: string): this
  get headers(): Array<[string, string]> | undefined
  setCookie(name: string, value: string, options?: CookieOptions): this
  getCookie(name: string): CookieInfo | undefined
  hasCookie(name: string): boolean
  /**
   * Sends cookie header that tells the browser to delete cookie with this name and (optionally) path.
   * Don't mix up with removeCookie method below
   */
  clearCookie(name: string, options?: Omit<CookieOptions, 'expires' | 'maxAge'>): this
  /**
   * Remove cookie definition "command" previously defined during this request.
   * This method doesn't delete actually set cookie in browser!
   * Don't mix up with clearCookie which sends header that tells browser - delete this cookie.
   */
  removeCookie(name: string): this
  get cookies(): CookieInfo[] | undefined
  setStatusCode(code: number): this
  setSimplifiedContentType(type: SimplifiedContentType): this
  screen<T = unknown>(data: T): T
  json<T = unknown>(data: T): T
  html<T = unknown>(data: T): T
  plain<T = unknown>(data: T): T
  redirect(location: string, statusCode?: number): this
}
declare type SimplifiedContentType = 'screen' | 'json' | 'html' | 'plain' | 'unknown'
interface CookieInfo extends CookieOptions {
  name: string
  value: string
}
interface CookieOptions {
  expires?: Date
  maxAge?: number
  path?: string
  sameSite?: boolean | 'lax' | 'strict' | 'none'
}
declare type UgcRouter404ErrorHook = (ctx: RichUgcCtx, req: UgcRouteParsedRequest) => Promise<unknown>
declare type IapUpdatedHook = (ctx: RichUgcCtx, iapIds: string[]) => Promise<void>
declare type UserMergeHook = (ctx: RichUgcCtx, payload: UserMergeHookPayload) => Promise<void>
interface UserMergeHookPayload {
  fromUserId: HeapId
  toUserId: HeapId
}
declare type UserProfileHook = {
  obtainExtendedUserInfo?(
    ctx: RichUgcCtx,
    coreUsers: Record<HeapId, UgcCtxUser2>,
  ): Promise<Record<HeapId, ExtendedUserInfo>>
  updateExtendedUserInfo?(
    ctx: RichUgcCtx,
    coreUser: UgcCtxUser2,
    info: UpdateExtendedUserInfo,
  ): Promise<ExtendedUserInfo>
  findUserIdsByFuzzyText?(ctx: RichUgcCtx, word: string): Promise<HeapId[]>
  getExtendedUserFieldsSupport?(ctx: RichUgcCtx): Promise<ExtendedUserFieldsSupport>
}
declare type MetricEventHook = (ctx: RichUgcCtx, payload: MetricEventHookPayload) => Promise<void>
interface MetricEventHookPayload {
  event: MetricEventRecord
  params: JSONValue
  groupKey: string | null
}
declare function registerUgcHook(hookName: 'user-profile', value: UserProfileHook): void
declare function registerUgcHook(hookName: 'user-merge', value: UserMergeHook): void
declare function registerUgcHook(hookName: 'iap-updated-by-user', value: IapUpdatedHook): void
declare function registerUgcHook(hookName: 'iap-updated-txns', value: IapUpdatedHook): void
declare function registerUgcHook(hookName: '404', value: UgcRouter404ErrorHook): void
declare function registerUgcHook(hookName: 'auth-provider', value: AuthProviderHook): void
declare function registerUgcHook(hookName: 'metric-event', value: MetricEventHook): void
declare function registerUgcHook(
  hookName: string,
  value: (ctx: RichUgcCtx, params: JSONValue) => void | unknown | Promise<unknown | void>,
): void
declare type Middleware<Ctx, Req> = {
  <R>(ctx: Ctx, req: Req, next: () => R): R | Promise<R>
}
declare type UgcRoutesDefinitionMiddleware = Middleware<RichUgcCtx, UgcRouteParsedRequest>
export declare class RoutesDefinitionApi {
  readonly accountHook: typeof registerUgcHook
  readonly pluginHook: typeof registerUgcHook
  private readonly registeredMiddlewares
  constructor(middlewares: UgcRoutesDefinitionMiddleware[])
  use(...middlewares: UgcRoutesDefinitionMiddleware[]): RoutesDefinitionApi
  screen<Handler extends ScreenRouteHandlerFn>(
    pattern: string,
    handler: Handler,
  ): GetRouteRef<GetReturnTypeOfHandler<Handler>>
  apiCall<Handler extends ApiCallRouteHandlerFn>(
    pattern: string,
    handler: Handler,
  ): ApiCallRouteRef<Handler extends ApiCallRouteHandlerFn<infer Body> ? Body : never, GetReturnTypeOfHandler<Handler>>
  get<Handler extends CustomRouteHandlerFn>(
    pattern: string,
    handler: Handler,
  ): GetRouteRef<GetReturnTypeOfHandler<Handler>>
  post<Handler extends CustomRouteHandlerFn>(
    pattern: string,
    handler: Handler,
  ): PostRouteRef<Handler extends CustomRouteHandlerFn<infer Body> ? Body : never, GetReturnTypeOfHandler<Handler>>
  job<P extends JSONInputValue | undefined, R extends JSONInputValue | void>(
    path: string,
    handler: CustomJobHandlerFn<P, R>,
  ): JobRouteRef<P, R>
  html(pattern: string, handler: CustomRouteHandlerFn): GetRouteRef
  /**
   * @deprecated use import { requireRealUser } from '@app/auth'
   */
  requireRealAuth(ctx: RichUgcCtx): void
  /**
   * @deprecated use import { requireAccountRole } from '@app/auth'
   */
  requireAdminRole(ctx: RichUgcCtx): void
}
declare type ScreenRouteHandlerFn = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest,
) => UgcScreenHandlerResult | Promise<UgcScreenHandlerResult>
declare type ApiCallRouteHandlerFn<Body = any> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<Body>,
) => UgcApiCallHandlerResult | Promise<UgcApiCallHandlerResult>
declare type CustomRouteHandlerFn<Body = any> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<Body>,
) => UgcCustomHandlerResult | Promise<UgcCustomHandlerResult>
declare type CustomJobHandlerFn<P extends JSONInputValue | undefined, R extends JSONInputValue | void> = (
  ctx: RichUgcCtx,
  params: P,
) => R | Promise<R>
declare type UgcScreenHandlerResult = ScreenPropsV2 | ScreenSuccessResponseV2 | ScreenErrorResponseV2
declare type UgcApiCallHandlerResult =
  | undefined
  | null
  | void
  | ChatiumActions
  | ApiCallResponseFields
  | ApiCallSuccessResponse
  | (UgcErrorResponse & ApiCallResponseFields)
declare type UgcCustomHandlerResult = unknown | TuneHttpHeadersResponse | UgcErrorResponse
declare type GetReturnTypeOfHandler<Handler> = Handler extends ScreenRouteHandlerFn
  ? ReturnType<Handler>
  : Handler extends ApiCallRouteHandlerFn
  ? ReturnType<Handler>
  : Handler extends CustomRouteHandlerFn
  ? GetReturnTypeOfCustomRouteHandlerFn<ReturnType<Handler>>
  : never
declare type GetReturnTypeOfCustomRouteHandlerFn<V> = V extends TuneHttpHeadersResponse<infer Body> ? Body : V
interface UgcErrorResponse {
  success: false
  errorType?: string
  statusCode: number
  reason?: string
  __type__?: 'getScreen' | 'apiCall' | 'getHtml'
  [key: string]: unknown
}
declare class CtxConsole {
  private logFn?
  constructor(
    logFn?:
      | import('isolated-vm').Reference<
          (level: 'error' | 'debug' | 'log' | 'warn' | 'info', ...args: unknown[]) => void
        >
      | undefined,
  )
  debug(...args: unknown[]): void
  log(...args: unknown[]): void
  info(...args: unknown[]): void
  warn(...args: unknown[]): void
  error(...args: unknown[]): void
  private writeLog
}
declare type ReqQuery = Record<string, string | string[] | undefined>
declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'unknown'
declare type UgcKvOpts = {
  [key: string]: string | number | undefined
}
declare type LogParams = {
  err?: Error
  kv?: UgcKvOpts
  json?: unknown
  level?: LogLevel
  msg?: string | number
}
declare type LogParamsNoMsg = Omit<LogParams, 'msg'>
declare class RichUgcAccount implements Omit<UgcCtxAccount, 'metaHash'> {
  private acc
  private richUgcCtx
  readonly id: number
  readonly name: string
  readonly host: string
  readonly pathPrefix: string
  readonly authType: AccountAuthType
  private readonly metaHash
  constructor(acc: UgcCtxAccount, richUgcCtx: RichUgcCtx)
  get externalHost(): string | null
  get publishedVersion(): string | null
  url: AccountUrlFn
  apiCall<P>(url: string, apiParams?: P, options?: Parameters<typeof apiCall>[2]): ApiCallAction<P>
  navigate(url: string, options?: Parameters<typeof navigate>[1]): ReturnType<typeof navigate>
  /** @deprecated use ctx.account.url(path) instead */
  externalUrl(path: string): string
  redirect(targetPath: string): never
  /**
   * Returns attachMedia action targeted to the proper chatium file-service url bound to the account
   */
  attachMedia(params: Omit<AttachMediaAction, 'type' | 'filePutUrl' | 'getPutUrl'>): AttachMediaAction
  toJSON(): UgcCtxAccount
  log(params: LogParams): void
  log(msg: string | number, params?: LogParamsNoMsg): void
  log(msg: string | number, err?: Error): void
  log(err: Error): void
}
/**
 * Context provided to end-user code enriched with some helper methods
 */
export declare class RichUgcCtxDef
  implements Omit<UgcCtx, 'account' | 'app' | 'auth1' | 'rc' | 'router' | 'user2' | 'user1'>
{
  readonly account: RichUgcAccount
  readonly auth?: UgcCtxBaseAuth & {
    expiresAt?: Date
  }
  readonly authSession?: UgcAuthSession
  readonly app: {
    readonly account: {
      readonly id: number
      readonly host: string
      readonly name: string
      readonly apiCall: typeof apiCall
      readonly navigate: typeof navigate
      readonly owner: UgcCtxUser1 | null
      url(path: string): string
      externalUrl(path: string): string
    }
    readonly apiCall: typeof apiCall
    readonly navigate: typeof navigate
    readonly user: UgcCtxUser1 | null
    url(path: string): string
  }
  readonly env: UgcCtx['env']
  readonly location: UgcCtxLocation | undefined
  readonly rc: UgcCtxRc
  readonly router: Pick<DeprecatedCtxRouter, 'filePath' | 'urlPath'>
  readonly session: UgcCtx['session']
  readonly timeZone: UgcCtx['timeZone']
  readonly user?: UgcSmartUser
  readonly req: UgcRouteParsedRequest<any>
  readonly resp: UgcHttpResponseTuner
  readonly console: CtxConsole
  readonly traceId: string
  readonly routeType?: UgcCtxRouteType
  private _lang
  /** accountId -> bundles */
  private langBundles
  /**
   * List of langs, whose bundles are actually loaded in langBundles and are effective for the ctx.t calls.
   * This list is used to preserve consistent logic when transferring translation for the client-side (browser) code.
   */
  private __effectiveLangs__
  private __keyLangPerAccount__
  /**
   * Same as langBundles but may contain empty slots in bundle lists for each account.
   * Helps to match lang bundles with order of __effectiveLangs__.
   * @see RichUgcCtxHiddenLangFeatures
   * @see getUntranslatedI18nKeys
   */
  private rawLangBundles
  constructor(ctx: UgcCtx, ctxFns: CtxOutsideFns, req: UgcRouteRequest)
  constructor(ctx: UgcInternalCtx, ctxFns: CtxOutsideFns)
  log(...args: unknown[]): void
  /**
   * @deprecated use import { requireAnyUser, requireRealUser } from '@app/auth'
   */
  getOrCreateUser(): Promise<UgcCtxUser1>
  toJSON(): UgcInternalCtx
  t(key: string, args?: TranslateArgs): string
  t(key: string | undefined, args?: TranslateArgs): string | undefined
  t(key: string | null, args?: TranslateArgs): string | null
  t(key: TranslationKey, args?: DynamicTranslateArgs): string
  t(key: TranslationKey | undefined, args?: DynamicTranslateArgs): string | undefined
  t(key: TranslationKey | null, args?: DynamicTranslateArgs): string | null
  t(key: TranslationKey | string, args?: TranslateArgs): string
  t<T extends null | undefined>(key: null | undefined, args?: TranslateArgs): T
  get lang(): Lang
  /**
   * Optionaly changes the current request lang and loads corresponding lang bundles (translations),
   *  so all necessary translations are available synchronously for ctx.t function
   */
  updateAndLoadLang(lang?: Lang): Promise<Lang>
}
declare type DeprecatedCtxRouter = UgcCtx['router'] & {
  params: Record<string, unknown>
  readonly apiCall: typeof apiCall
  readonly navigate: typeof navigate
  setParam(key: string, val: unknown): Promise<void>
  url(path: string): string
  redirect(path: string): never
}
declare type UgcCtxRouteType = 'screen' | 'apiCall' | 'get' | 'post' | 'html' | 'job'
declare type User2 = HeapObjectBaseV2 & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
interface ChatiumRc {
  defaultDesktopLayout?: DesktopLayout
  favicon?: string
  faviconHash?: string
  fonts?: ScreenPropsV2['fonts']
  htmlTemplate?: string
  ogDescription?: string
  ogImage?: string
  ogImageHash?: string
  ogTitle?: string
  ogType?: string
  title?: string
  titleScreen?: string
  headExtra?: string[]
  bodyExtra?: string[]
  layout?: Layout | string
  i18n?: {
    /**
     * Language, in which the in-code key strings are defined.
     * It's important to only set this if the keys are really of that language, not technical IDs
     *  because this info is used for proper language bundle loading.
     */
    keyLang?: Lang | null
    /**
     * List of languages to which auto-translation actions will target when they are activated
     */
    autoTranslateLangs?: Lang[]
    /**
     * List of languages that are considered supported in this account.
     * 'auto-detect-all' (default) - collect a combined set of translation languages from the account code,
     *                               external dependencies, and all connected plugin apps.
     * 'auto-detect-local-with-externals' - collect a combined set of translation languages only from the account code
     *                                      and external dependencies, without plugin apps
     * 'auto-detect-only-local' - collect a combined set of translation languages only from the account's own code
     *
     * Alternatively, an explicit list of languages may be provided which disable auto-detection.
     * @see getSupportedTranslationLangs
     */
    supportedLangs?: typeof i18nSupportedLangsAutoValues[number] | Lang[]
  }
  signInPath?: string
  globalJsx?: 'app/ui' | false
}
declare const i18nSupportedLangsAutoValues: readonly [
  'auto-detect-all',
  'auto-detect-local-with-externals',
  'auto-detect-only-local',
]
interface Layout {
  leftMenu?: {
    items?: LayoutMenuItem
  }
  bottomTabs?: LayoutBottomTabs
}
interface LayoutBottomTabs {
  tabs?: LayoutMenuItem[]
  activeTintColor?: string
  inactiveTintColor?: string
}
interface LayoutMenuItem {
  id?: string
  type: 'tab' | 'button'
  title?: string
  url?: string
  onClick?: ChatiumActions
  icon: IconProps
  key?: string
}
declare class ResponsiveState {
  readonly viewportWidth: number
  readonly breakpoints: ResponsiveBreakpoints
  readonly desktopLayout: DesktopLayout
  constructor(
    ctx: EnvCtx & {
      rc: Pick<ChatiumRc, 'defaultDesktopLayout'>
    },
    options: ResponsiveStateOptions,
  )
  get xl(): boolean
  get xlOnly(): boolean
  get xlDown(): boolean
  get lg(): boolean
  get lgOnly(): boolean
  get lgDown(): boolean
  get md(): boolean
  get mdOnly(): boolean
  get mdDown(): boolean
  get sm(): boolean
  get smOnly(): boolean
  get smDown(): boolean
  get xs(): boolean
  get xsOnly(): boolean
  get xsDown(): boolean
  get currentBreakpoint(): keyof ResponsiveBreakpoints | null
  /**
   * This and following xxxStyle - helper for type-safe and convenient
   *  support of responsive style keys for the corresponding chatium-json block via this format:
   *    {
   *      margin: 10,
   *      xl: { margin: 20 }
   *    }
   *  which is syntax sugar for:
   *    [
   *      { margin: 10 },
   *      responsive.xl && { margin: 20 },
   *    ]
   * @see style
   */
  audioStyle(...style: ResponsiveStyleList<AudioProps.Style>[]): SingleOrArray<AudioProps.Style> | undefined
  boxStyle(...style: ResponsiveStyleList<BoxProps.Style>[]): SingleOrArray<BoxProps.Style> | undefined
  buttonStyle(...style: ResponsiveStyleList<ButtonProps.Style>[]): SingleOrArray<ButtonProps.Style> | undefined
  footerStyle(...style: ResponsiveStyleList<FooterProps.Style>[]): SingleOrArray<FooterProps.Style> | undefined
  headerStyle(...style: ResponsiveStyleList<HeaderProps.Style>[]): SingleOrArray<HeaderProps.Style> | undefined
  horizontalScrollStyle(
    ...style: ResponsiveStyleList<HorizontalScrollProps.Style>[]
  ): SingleOrArray<HorizontalScrollProps.Style> | undefined
  iapProductStyle(
    ...style: ResponsiveStyleList<IAPProductProps.Style>[]
  ): SingleOrArray<IAPProductProps.Style> | undefined
  iconStyle(...style: ResponsiveStyleList<IconProps.Style>[]): SingleOrArray<IconProps.Style> | undefined
  imageStyle(...style: ResponsiveStyleList<ImageProps.Style>[]): SingleOrArray<ImageProps.Style> | undefined
  listItemStyle(...style: ResponsiveStyleList<ListItemProps.Style>[]): SingleOrArray<ListItemProps.Style> | undefined
  parallaxStyle(...style: ResponsiveStyleList<ParallaxProps.Style>[]): SingleOrArray<ParallaxProps.Style> | undefined
  smartIconStyle(...style: ResponsiveStyleList<SmartIconProps.Style>[]): SingleOrArray<SmartIconProps.Style> | undefined
  stickyStyle(...style: ResponsiveStyleList<StickyProps.Style>[]): SingleOrArray<StickyProps.Style> | undefined
  textStyle(...style: ResponsiveStyleList<TextProps.Style>[]): SingleOrArray<TextProps.Style> | undefined
  textInputStyle(...style: ResponsiveStyleList<TextInputProps.Style>[]): SingleOrArray<TextInputProps.Style> | undefined
  searchInputStyle(
    ...style: ResponsiveStyleList<SearchInputProps.Style>[]
  ): SingleOrArray<SearchInputProps.Style> | undefined
  videoStyle(...style: ResponsiveStyleList<VideoProps.Style>[]): SingleOrArray<VideoProps.Style> | undefined
  videoPosterStyle(
    ...style: ResponsiveStyleList<VideoPosterProps.Style>[]
  ): SingleOrArray<VideoPosterProps.Style> | undefined
  /**
   * Common algorithm of converting ResponsiveStyle (style with responsive sub-style keys)
   *  to ordered list of usual styles depending on current responsive state.
   * Precedence of the responsive flags (from least priority to most):
   *   xs, sm, md, lg, xl, xlDown, lgDown, mdDown, smDown, xsDown, xsOnly, smOnly, mdOnly, lgOnly, xlOnly
   * General priciple: more specific and precise predicate data overwrites the less one.
   * @see breakpointPredicatesPriority
   */
  private style
}
declare type ResponsiveStateOptions = ResponsiveBreakpoints & {
  desktopLayout?: DesktopLayout
}
interface ResponsiveBreakpoints {
  xs: number
  sm: number
  md: number
  lg: number
  xl: number
}
interface ResponsiveInfo {
  breakpoints: ResponsiveBreakpoints
  width?: number
  height?: number
}
declare type ResponsiveKeys = keyof ResponsiveBreakpoints
declare type ResponsiveBreakpointsPredicateKeys = ResponsiveKeys | `${ResponsiveKeys}Only` | `${ResponsiveKeys}Down`
declare type ResponsiveStyle<T> = T & {
  [K in ResponsiveBreakpointsPredicateKeys]?: T
}
declare type ResponsiveStyleList<T> = SingleOrArrayRecursiveNullable<ResponsiveStyle<T>>
declare type ScreenAsyncProps = Omit<ScreenPropsV2, 'type' | 'blocks'> & {
  responsive?: ResponsiveInfo | ResponsiveState
}
interface ScreenPropsV2 extends CommonBlockProps {
  type: 'blocks'
  title?: string
  icon?: Pick<SmartIconProps, 'name' | 'url' | 'text'>
  fonts?: ScreenFonts
  blocks?: ChatiumBlockV2[]
  responsive?: ResponsiveInfo
  style?: BlockStyle<ScreenStyle>
  socketId?: string
  socketIds?: string[] | Record<string, ChatiumActions | 'reload'>
  desktopLayout?: DesktopLayout
  /** @deprecated renamed to desktopLayout */
  layout?: DesktopLayout
  columnLayoutStyle?: BlockStyle<ColumnLayoutStyle>
  meta?: ScreenMeta
  preventScreenCapture?: boolean
  onFocus?: ChatiumActions
}
declare type DesktopLayout = 'column' | 'empty' | 'mobile'
declare type ScreenMeta = {
  [key: string]: unknown
  favicon?: string
  faviconHash?: string
  ogType?: string
  ogTitle?: string
  ogDescription?: string
  ogImage?: string
  headExtra?: string[] | string
  bodyExtra?: string[] | string
  layout?: {
    url: string
    bottomTabs: LayoutBottomTabs
  }
}
declare type ScreenFonts = {
  [fontFamily: string]: string | Array<ScreenFontDef>
}
declare type ScreenFontDef = {
  url: string
  fontWeight?: NonNullable<TextProps.Style['fontWeight']>
  fontStyle?: NonNullable<TextProps.Style['fontStyle']>
  fontVariant?: NonNullable<TextProps.Style['fontVariant']>
}
declare type ScreenBackgroundImageStyle = {
  backgroundImage?: string
}
declare type ScreenStyle = BackgroundColorStyle & BackgroundGradientStyle & ScreenBackgroundImageStyle
declare type ColumnLayoutStyle = BackgroundColorStyle &
  BackgroundGradientStyle &
  ScreenBackgroundImageStyle &
  ShadowStyle &
  ColumnLayoutBorderStyle
declare type ColumnLayoutBorderStyle = {
  borderWidth?: BorderWidth
  borderColor?: Color
  border?: BorderShortDef
}
interface ScreenSuccessResponseV2 extends ScreenResponseFieldsV2 {
  success: true
}
interface ScreenErrorResponseV2 extends ChatiumErrorResponse, Partial<ScreenResponseFieldsV2> {}
interface ScreenResponseFieldsV2 {
  data: ScreenPropsV2
  appScreens?: Record<string, ScreenPropsV2>
  preloadMedia?: string[]
}
interface V2IntrinsicElements {
  audio: AudioProps
  box: BoxAsyncProps
  button: ButtonAsyncProps
  footer: FooterAsyncProps
  header: HeaderAsyncProps
  'horizontal-scroll': HorizontalScrollAsyncProps
  'horizontal-scroll-indicator': HorizontalScrollIndicatorProps
  'iap-product': IAPProductAsyncProps
  icon: IconProps
  image: ImageProps
  'list-item': ListItemAsyncProps
  parallax: ParallaxAsyncProps
  screen: ScreenAsyncProps
  'search-input': SearchInputProps
  'smart-icon': SmartIconProps
  sticky: StickyAsyncProps
  text: TextProps
  'text-input': TextInputProps
  'text-input-indicator': TextInputIndicatorProps
  video: VideoProps
  'video-poster': VideoPosterProps
}
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface EnvCtx {
  env: Env
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type AuthSession = PublicFieldsOfClass<AuthSessionHelperClass>
declare class AuthSessionHelperClass {
  id: string
  account_id: number
  user_id: string
  auth_log: AuthLogItem[]
  device_name: string
  is_mobile: boolean
  os_name: string
  last_ip: string
  last_active_approx_at: Date
  created_at: Date
  /**
   * matching session token from the external auth provider or device ID for the anonymous user sessions
   * helps to avoid creating a new session duing upstream provider session revalidation
   * @see getOrCreateExternalAuthSession
   */
  external_token: string | null
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    auth_log: AuthLogItem[],
    device_name: string,
    is_mobile: boolean,
    os_name: string,
    last_ip: string,
    last_active_approx_at: Date,
    created_at: Date,
    /**
     * matching session token from the external auth provider or device ID for the anonymous user sessions
     * helps to avoid creating a new session duing upstream provider session revalidation
     * @see getOrCreateExternalAuthSession
     */
    external_token: string | null,
  )
}
interface AuthLogItem {
  provider: AuthProvider
  /**
   * Provider-specific additional data provided by the provider that can be used for later system call to the provider.
   */
  providerData?: AnyObject
  /**
   * 'AuthSession' means that this session has been authenticated by another active session with the session ID as a key
   */
  type: IdentityType | 'AuthSession'
  key: string
  authAt: number
}
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare enum AccountType {
  Chatium = 'Chatium',
  Getcourse = 'Getcourse',
  FollowersClub = 'FollowersClub',
  Playground = 'Playground',
  Reserved = 'Reserved',
}
declare type UgcCodeVersion = CgsRepoVersion
interface UgcRouteRequest<Body = any> {
  method: UgcRequestMethod
  path: string
  query?: ReqQuery
  headers?: Record<string, string | undefined>
  body?: Body
}
export interface UgcRouteParsedRequest<Body = any> extends UgcRouteRequest<Body> {
  params: Record<string, string>
  query: ReqQuery
  /** like in node, without protocol and domain, starting with slash, normalized, includes query params */
  url: string
}
declare type UgcRequestMethod = 'get' | 'post' | 'job'
declare type UgcCtxBaseAuth = Pick<Auth, 'id' | 'type' | 'key'>
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
declare type UgcAuthSession = Pick<AuthSession, 'id' | 'auth_log'> & {
  deviceName: string
}
declare type UgcCtxLocation = Location
interface UgcCtx extends UgcInternalCtx {
  router: {
    id: EntityId
    parentId: EntityId | null
    filePath: string
    name: string
    urlPath: string
    params?: Record<string, unknown> | null
  }
}
interface UgcInternalCtx extends EnvCtx, LangCtx {
  account: UgcCtxAccount
  app?: UgcCtxApp
  authSession?: UgcAuthSession
  user2?: UgcCtxUser2 | SerializedSmartUser
  location: UgcCtxLocation | undefined
  rc?: UgcCtxRc
  session: UgcCtxSession | null
  timeZone: string
  traceId: string
  auth1?:
    | (UgcCtxBaseAuth & {
        expiresAtMs?: number
      })
    | undefined
  user1?: UgcCtxUser1
}
declare type UgcCtxApp = UgcCtxProxyApp | UgcCtxPluginApp
interface UgcCtxPluginApp extends UgcPluginAppUrlInfo {
  type: 'UgcPlugin'
  appId: number
  callingAcc: UgcCtxAccount
  hostAccUser1?: UgcCtxUser1
  hostAccUser2?: UgcCtxUser2 | SerializedSmartUser
}
interface UgcPluginAppUrlInfo {
  appSlug: string
  /** path to the application root directory */
  directoryPath: string
}
interface UgcCtxProxyApp {
  type: 'UgcProxy'
  accId: number
  accName: string
  accHost: string
  accOwner: UgcCtxUser1 | null
  accUrl: string
  accExternalHost: string | null
  accPathPrefix: string | null
  appPrefix: string
  directoryPath: string | null
  user: UgcCtxUser1 | null
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
declare type UgcCtxRc = Pick<ChatiumRc, 'defaultDesktopLayout'>
interface UgcCtxSession {
  id: string
  email?: string
  phone?: string
}
declare type AnyObject = Record<string, unknown>
declare type FilterObject<T> =
  | FilterSingleObject<T>
  | TopAndOperator<T>
  | TopOrOperator<T>
  | TopNotOperator<T>
  | NoopOperator
declare type FilterSingleObject<T> = {
  [K in keyof T]?: FilterRighthand<T[K]>
}
declare type TopAndOperator<T> = {
  $and: Array<FilterObject<T>>
}
declare type TopOrOperator<T> = {
  $or: Array<FilterObject<T>>
}
declare type TopNotOperator<T> = {
  $not: FilterObject<T>
}
declare type FilterRighthand<V> =
  | null
  | V
  | Array<V>
  | Operator<V>
  | FilterSingleObject<V>
  | (V extends Date ? DateHint : never)
declare type Operator<V> =
  | GtOperator<V>
  | GteOperator<V>
  | LtOperator<V>
  | LteOperator<V>
  | HasOperator<V>
  | IncludesOperator<V>
  | NotOperator<V>
  | AndOperator<V>
  | OrOperator<V>
  | IlikeOperator<V>
  | NoopOperator
declare type GtOperator<V> = {
  $gt: V
}
declare type GteOperator<V> = {
  $gte: V
}
declare type LtOperator<V> = {
  $lt: V
}
declare type LteOperator<V> = {
  $lte: V
}
declare type IlikeOperator<V> = V extends string
  ? {
      $ilike: V
    }
  : never
declare type HasOperator<V> = {
  $has: V extends AnyObject ? keyof V : never
}
declare type IncludesOperator<V> = {
  $includes:
    | ArrayElement<V>
    | {
        $any: ArrayElement<V>[]
      }
    | {
        $all: ArrayElement<V>[]
      }
}
declare type NoopOperator = {
  $noop: unknown
}
declare type NotOperator<V> = {
  $not: FilterRighthand<V>
}
declare type AndOperator<V> = {
  $and: Array<FilterRighthand<V>>
}
declare type OrOperator<V> = {
  $or: Array<FilterRighthand<V>>
}
declare type DateHint = {
  $date: string
}
declare type ArrayElement<V> = V extends unknown[] ? V[number] : never
export declare type SmartTextProps = TextProps & {
  size?: number | StandardFontSize
  color?: Color
}
export declare type SmartImageProps = ImageProps & {
  src: ImageProps['src'] | string
}
export declare type UGCIntrinsicElements = Omit<V2IntrinsicElements, 'text' | 'image'> & {
  text: SmartTextProps
  image: SmartImageProps
  img: SmartImageProps
  section: BoxProps
  b: SmartTextProps
  p: SmartTextProps
}
export declare function jsx(block: BlockFactory | string, props?: AnyObject, ...children: Array<any>): JsxNode
export declare namespace jsx {
  const Fragment: typeof JsxFragment
  namespace JSX {
    type IntrinsicElements = UGCIntrinsicElements
  }
}
declare type BlockFactory = (props?: AnyObject, ...children: JsxNode[]) => JsxNode
declare type JsxNode =
  | ChatiumChildNode
  | ChatiumChildNode[]
  | ChatiumScreen
  | Promise<ChatiumChildNode | ChatiumChildNode[] | ChatiumScreen>
export declare namespace app {
  type Ctx = RichUgcCtx
  type Req<Body = any> = UgcRouteParsedRequest<Body>
}

export {}
