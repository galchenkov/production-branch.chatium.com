import * as tb from '@sinclair/typebox'
import { Static } from '@sinclair/typebox'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import {
  HeapObjectBaseSchema,
  HeapObjectBaseV2,
  HeapSchema,
  HsFilterInput,
  HsFilterInputObject,
  HsObject,
  HsProperties,
  HsProperty,
} from 'core/heap/v2/heapSchemaTypes'
import { HeapOrderByV2, HeapRecordFilter, HeapRecordSelectOptions } from 'core/heap/v2/types'
import { Icon, VideoSize } from 'lib/chatium-json/v1'
import { AudioBlock, ImageBlock, PlainIconName, VideoBlock } from 'lib/chatium-json/v2'
import { HeapTableNsType } from 'services/ugc-runner/runtime/runtimeTypes'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'

declare type OrderByDefinition<T> = SingleOrderBy<T> | Array<SingleOrderBy<T>>
declare type SortDirection =
  | 'asc'
  | 'desc'
  | 'asc nulls first'
  | 'asc nulls last'
  | 'desc nulls first'
  | 'desc nulls last'
declare type ValueTypeHint = '$string' | '$number' | '$date' | '$boolean'
declare type SingleOrderBy<T> = (keyof T & string) | ObjectOrderVariant<T>
declare type ObjectOrderVariant<T> = {
  [Field in keyof T & string]?: SingleOrderByValue<T[Field]>
}
declare type SingleOrderByValue<V> = V extends object
  ? ObjectOrderVariant<V>
  : SortDirection | ValueTypeHint | [ValueTypeHint, SortDirection]
declare type JSONValue = string | number | boolean | null | JSONValue[] | JSONObject
declare type JSONObject = {
  [key: string]: JSONValue
}
declare type JSONInputValue = string | number | boolean | null | JSONInputValue[] | JSONInputObject | undefined
declare type JSONInputObject = {
  [key: string]: JSONInputValue
}
declare type PublicFieldsOfClass<T> = {
  [Property in keyof T]: T[Property]
}
declare type Lang = string
interface LangCtx {
  lang: Lang
}
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare class HeapRecordHelperClass {
  id: HeapId
  idx: number
  account_id: number
  type: HeapObjectType
  data: object | null
  created_by: HeapId | null | undefined
  created_at: Date
  updated_by: HeapId | null | undefined
  updated_at: Date
  constructor(
    id: HeapId,
    idx: number,
    account_id: number,
    type: HeapObjectType,
    data: object | null,
    created_by: HeapId | null | undefined,
    created_at: Date,
    updated_by: HeapId | null | undefined,
    updated_at: Date,
  )
}
declare type HeapRecord = PublicFieldsOfClass<HeapRecordHelperClass>
interface HeapObjectBase {
  id: HeapId
  idx: number
  heapType: HeapObjectType
  createdAt: Date
  updatedAt: Date
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObject<HD extends HeapData> = HeapObjectBase & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
declare type HeapId = string
declare type HeapObjectType = string
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
interface VideoInfo {
  hash: string
  url: string | null
  hlsUrl: string | undefined
  mp4Url: string | undefined
  status: FileServiceResponse['status']
  progress: number
  imageUrl: string
  /** @deprecated always undefined */
  videoSize: VideoSize | undefined
  videoAspectRatio: [number, number] | undefined
}
interface FileServiceResponse {
  status: 'done' | 'processing' | 'error'
  width_aspect_ratio?: number
  height_aspect_ratio?: number
  progress?: number
  kinescopeVideoId?: string | number
  integrosVideoId?: string | number
  cloudflareVideoId?: string | number
}
declare abstract class StorageFile implements IStorageFile {
  readonly hash: string
  protected abstract readonly fileServiceHost: string
  constructor(hash: string)
  toJSON(): string
  get type(): HashMediaType
  get downloadUrl(): string
}
interface FileClass {
  new (hash: string): IStorageFile
}
interface IStorageFile {
  hash: string
  type: HashMediaType
  downloadUrl: string
  toJSON(): string
}
declare abstract class StorageFileWithSizes extends StorageFile implements IStorageFileWithSizes {
  #private
  get width(): number
  get widthMaybe(): number | undefined
  get height(): number
  get heightMaybe(): number | undefined
  get sizes(): {
    width: number
    height: number
  }
  get sizesMaybe():
    | {
        width: number
        height: number
      }
    | undefined
}
interface IStorageFileWithSizes extends IStorageFile {
  width: number
  widthMaybe: number | undefined
  height: number
  heightMaybe: number | undefined
  sizes: {
    width: number
    height: number
  }
  sizesMaybe:
    | {
        width: number
        height: number
      }
    | undefined
}
declare abstract class StorageImageFile extends StorageFileWithSizes implements IStorageImageFile {
  get type(): 'image'
  getThumbnailUrl(width?: number, height?: number): string
  /**
   * Returns the image's URL and sizes in format accepted by src property of <image> block.
   */
  getThumbnailSrc(width?: number, height?: number): ImageBlock['src']
}
interface ImageFileClass {
  new (hash: string): IStorageImageFile
}
interface IStorageImageFile extends IStorageFileWithSizes {
  getThumbnailUrl(width?: number, height?: number): string
  getThumbnailSrc(width?: number, height?: number): ImageBlock['src']
}
declare abstract class StorageVideoFile extends StorageFileWithSizes implements IStorageVideoFile {
  #private
  get type(): 'video'
  getThumbnailUrl(width?: number, height?: number, offsetSeconds?: 'auto' | number): string
  /**
   * Returns the video's frame thumbnail URL and sizes in format accepted by src property of <image> block.
   */
  getThumbnailSrc(width?: number, height?: number, offsetSeconds?: 'auto' | number): ImageBlock['src']
  get duration(): number
  get durationMaybe(): number | undefined
  get videoSrc(): Promise<VideoBlock['src']>
  get status(): Promise<'done' | 'processing' | 'error'>
  get progress(): Promise<number>
  protected abstract getVideoInfo(): Promise<VideoInfo>
  private get videoInfo()
}
interface VideoFileClass {
  new (hash: string): IStorageVideoFile
}
interface IStorageVideoFile extends IStorageFileWithSizes {
  duration: number
  durationMaybe: number | undefined
  videoSrc: Promise<VideoBlock['src']>
  status: Promise<'done' | 'processing' | 'error'>
  progress: Promise<number>
  getThumbnailUrl(width?: number, height?: number, offsetSeconds?: 'auto' | number): string
  getThumbnailSrc(width?: number, height?: number, offsetSeconds?: 'auto' | number): ImageBlock['src']
}
declare abstract class StorageAudioFile extends StorageFile implements IStorageAudioFile {
  #private
  get type(): 'audio'
  get duration(): number
  get durationMaybe(): number | undefined
  get audioSrc(): AudioBlock['src']
}
interface AudioFileClass {
  new (hash: string): IStorageAudioFile
}
interface IStorageAudioFile extends IStorageFile {
  duration: number
  durationMaybe: number | undefined
  audioSrc: AudioBlock['src']
}
interface HeapRuntimeClasses {
  RefLinkClass: RefLinkClass
  GenericLinkClass: GenericLinkClass
  FileClass: FileClass
  ImageFileClass: ImageFileClass
  VideoFileClass: VideoFileClass
  AudioFileClass: AudioFileClass
}
declare type HeapLinkInfo =
  | {
      refType: 'RefLink'
      fieldPath: string
      targetType: HeapObjectType
      id: HeapId
    }
  | {
      refType: 'GenericLink'
      fieldPath: string
      id: HeapId
    }
  | {
      fieldPath: string
      id: null
    }
interface HeapTableRecordApi<ReadCtx, WriteCtx> {
  findHeapRecordByTypeAndId(ctx: ReadCtx, type: HeapObjectType, id: HeapId): Promise<HeapRecord | null>
  findHeapRecordsByTypeAndIds(ctx: ReadCtx, type: HeapObjectType, ids: HeapId[]): Promise<HeapRecord[]>
  queryHeapRecords<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    options?: HeapRecordSelectOptions<HSP>,
  ): Promise<HeapRecord[]>
  queryHeapRecordIds<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    options?: HeapRecordSelectOptions<HSP>,
  ): Promise<HeapId[]>
  countHeapRecords<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    filter?: HeapRecordFilter<HSP> | null,
  ): Promise<number>
  createHeapRecord<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    linkInfo: HeapLinkInfo[],
    data: Static<HsObject<HSP>> & {
      id?: HeapId
    },
  ): Promise<HeapRecord>
  updateHeapRecordMaybe<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    linkInfo: HeapLinkInfo[],
    patch: Partial<Static<HsObject<HSP>>> & {
      id: HeapId
    },
    optionalFieldsToClear?: Array<keyof HSP>,
  ): Promise<HeapRecord | null>
  createOrUpdateHeapRecordBy<HSP extends HsProperties, K extends HsProperty<HSP>>(
    ctx: WriteCtx,
    type: HeapObjectType,
    uniqKey: K,
    linkInfo: HeapLinkInfo[],
    data: Static<HsObject<HSP>>,
  ): Promise<HeapRecord>
  deleteHeapRecord(ctx: WriteCtx, type: HeapObjectType, id: HeapId, hardDelete: boolean): Promise<HeapRecord | null>
  createOrUpdateSingleton<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    createLinkInfo: HeapLinkInfo[],
    createData: Static<HsObject<HSP>>,
    updateLinkInfo: HeapLinkInfo[],
    updatePatch: Partial<Static<HsObject<HSP>>>,
    optionalFieldsToClear?: Array<keyof HSP>,
  ): Promise<HeapRecord>
}
declare type HsSelectOptions<HSP extends HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HeapOrderByV2<HSP> | null | undefined
}
declare type HsFilter<HSP extends HsProperties> =
  | HsFilterInputObject<HSP & Pick<HeapObjectBaseSchema, 'id' | 'createdAt' | 'updatedAt' | 'createdBy' | 'updatedBy'>>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTopAndOperator<HSP extends HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends HeapSchema> = HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
declare abstract class ReadOnlyHeapTableRepo<HSP extends hs.HsProperties, ReadCtx, WriteCtx = ReadCtx> {
  readonly type: HeapObjectType
  protected readonly tableOptions?: HeapTableOptions<HSP> | undefined
  readonly schema: hs.HsObject<HSP>
  readonly T: hs.HsFullObjectRuntime<HSP>
  readonly JsonT: hs.HsObjectStatic<HSP>
  readonly PropsT: HSP
  readonly PatchT: Partial<hs.HsUpdateInputObject<HSP>>
  readonly CreateInputT: hs.HsCreateInputObject<HSP> & {
    id?: HeapId
  }
  /**
   * Low-level heap record API differs for core backend and UGC implementations
   * This helps to share a lot of high-level code written in this class for UGC/core implementations of the heap table
   */
  protected abstract recordApi: HeapTableRecordApi<ReadCtx, WriteCtx>
  /**
   * Runtime RefLink instance implementations differ for core backend and UGC in terms of
   *  how they implement .get() method, when only a string type repo is provided.
   *  Global registries of heap-table repos are organized differently
   */
  protected abstract runtimeClasses: HeapRuntimeClasses
  constructor(type: HeapObjectType, fields: hs.HsPropertiesNo$<HSP>, tableOptions?: HeapTableOptions<HSP> | undefined)
  /**
   * Type guard to easily recognize heap objects belonging to this table
   * May be useful in combination with generic links
   */
  isMyRecord(obj: unknown): obj is this['T']
  getById(ctx: ReadCtx, id: HeapId): Promise<this['T']>
  getRecordTitleById(ctx: ReadCtx, id: HeapId): Promise<string>
  /**
   * Generic method to get human-readable title of the record.
   * May be customized by tableOptions.getRecordTitleSync.
   * By default, it tries to use 'title' or 'name' fields, or just '#<id>'.
   */
  getRecordTitle(_ctx: ReadCtx, row: this['T']): Promise<string>
  findById(ctx: ReadCtx, id: HeapId): Promise<this['T'] | null>
  findByIds(ctx: ReadCtx, ids: HeapId[]): Promise<this['T'][]>
  findAll(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<this['T'][]>
  findAllIds(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<HeapId[]>
  findBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'][]>
  findOneBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'] | null>
  countBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<number>
  /**
   * Returns a singleton row of this table or a stub record with default values.
   * Treats the whole table as a single-row "singleton".
   * All fields of this table must be Heap.NonRequired, Heap.Nullable or Heap.Optional,
   *  or at least have a "default" option defined.
   */
  getSingleton(ctx: ReadCtx): Promise<this['T']>
  protected getDefaultSingleton(): this['T']
  protected rawToObject: (hr: HeapRecord) => this['T']
  get customMeta(): NonNullable<hs.HsCustomMetaOption['customMeta']>
  /**
   * Augments and converts where and order options according to the schema
   * DRY
   */
  private prepareSelectOptions
}
declare abstract class HeapTableRepo<HSP extends hs.HsProperties, ReadCtx, WriteCtx> extends ReadOnlyHeapTableRepo<
  HSP,
  ReadCtx,
  WriteCtx
> {
  /**
   * Lazy-cached internal structure helping with detecting absent ref-link values,
   *  meaning that ref-link-tracking should be cleared for the respective fields.
   */
  private cachedLinkPaths
  private validateFn
  private validateUpdateFn
  create(ctx: WriteCtx, data: this['CreateInputT']): Promise<this['T']>
  update(
    ctx: WriteCtx,
    patch: Partial<hs.HsUpdateInputObject<HSP>> & {
      id: HeapId
    },
  ): Promise<this['T']>
  updateMaybe(
    ctx: WriteCtx,
    patch: this['PatchT'] & {
      id: HeapId
    },
  ): Promise<this['T'] | null>
  createOrUpdateBy<K extends hs.HsProperty<HSP>>(
    ctx: WriteCtx,
    uniqKey: K,
    data: hs.HsCreateInputObject<HSP> & Record<K, CreateOrUpdateUniqValue<HSP, K>>,
  ): Promise<this['T']>
  delete(ctx: WriteCtx, id: HeapId, hard?: boolean): Promise<this['T'] | null>
  /**
   * Updates a singleton row.
   * If the row doesn't exist, creates (materializes) it with default values
   *  for fields that are not provided in the `data` argument.
   * Fails with DataConsistencyError if there is more than one record in this table.
   * Should be used only with "singleton" tables which are accessed only via getSingleton method.
   * Returns the updated record.
   */
  updateSingleton(ctx: WriteCtx, data: hs.HsCreateInputObject<HSP>): Promise<this['T']>
  /**
   * Deletes a singleton row of the table if it exists.
   * Fails with DataConsistencyError if there is more than one record in this table.
   * Should be used only with "singleton" tables which are accessed only via getSingleton method.
   * Returns a default stub record with default values defined by the table schema.
   */
  resetSingleton(ctx: ReadCtx & WriteCtx): Promise<this['T']>
  /**
   * This hidden method supports defining explicit idx field, which should never be used in usual cases.
   * It's needed only in one case - auto-migration of RefLinks from old getcourse user cache to v2 (Multi) users.
   * @internal
   * @see createNewGcUserWithIdentities
   */
  private _create
  private get validate()
  private get validateUpdate()
  private getLinksPaths
}
interface HeapTableOptions<HSP extends hs.HsProperties> extends hs.HsCustomMetaOption {
  getRecordTitleSync?(record: hs.HsFullObjectRuntime<HSP>): string | null | undefined
}
declare type CreateOrUpdateUniqValue<HSP extends hs.HsProperties, K extends keyof HSP> = Static<HSP[K]> extends
  | string
  | number
  ? hs.HsCreateInput<HSP[K]>
  : never
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends HsProperties = HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>)
  get<R = HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends HsProperties = HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>): BaseGenericLink
}
export declare type GenericLinkJson = [HeapObjectType, HeapId]
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObject<UserData>
declare type UgcSystemHeapTableName = 'users'
declare type UgcHeapRegistryLocalTable =
  | Record<'tableName' | 'modulePath' | 'exportName', string>
  | {
      tableName: string
      modulePath: string
      exportName: string
    }
declare type UgcPluginAppVmInfo = Pick<UgcCtxPluginApp, 'appId' | 'appSlug' | 'directoryPath'> & {
  /** @deprecated use codeAccount.id */
  hostAccId: number
  /** @deprecated use codeAccount.name */
  hostAccName: string
  codeAccount: UgcCtxAccount
}
declare class StorageFile extends sf.StorageFile implements sf.IStorageFile {
  protected readonly fileServiceHost: string
}
declare class StorageImageFile extends sf.StorageImageFile implements sf.IStorageImageFile {
  protected readonly fileServiceHost: string
}
declare class StorageVideoFile extends sf.StorageVideoFile implements sf.IStorageVideoFile {
  protected readonly fileServiceHost: string
  protected getVideoInfo(): Promise<VideoInfo>
}
declare class StorageAudioFile extends sf.StorageAudioFile implements sf.IStorageAudioFile {
  protected readonly fileServiceHost: string
}
declare class UgcRefLink<T extends object> extends BaseRefLink<T, RichUgcCtx> {
  protected prefetchValue: T | undefined
  /**
   * This method called by `prefetchFields` method. Allow to make batched prefetch values for
   * a bunch of reflink instances
   *
   * @param ctx
   * @param values
   */
  static prefetch(ctx: RichUgcCtx, values: Array<UgcRefLink<object>>): Promise<void>
  getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: RichUgcCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
  get<R = T>(ctx: RichUgcCtx): Promise<R>
}
declare class UgcGenericLink extends BaseGenericLink<RichUgcCtx> {
  getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: RichUgcCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
}
declare type UgcAnyHeapTableRepo<HSP extends hs.HsProperties> = UgcReadOnlyHeapTableRepo<HSP> | UgcHeapTableRepo<HSP>
declare class UgcReadOnlyHeapTableRepo<HSP extends hs.HsProperties> extends ReadOnlyHeapTableRepo<
  HSP,
  RichUgcCtx,
  RichUgcCtx
> {
  readonly tableName: string
  protected recordApi: UgcHeapTableRecordApi
  protected runtimeClasses: {
    RefLinkClass: typeof UgcRefLink
    GenericLinkClass: typeof UgcGenericLink
    FileClass: typeof StorageFile
    ImageFileClass: typeof StorageImageFile
    VideoFileClass: typeof StorageVideoFile
    AudioFileClass: typeof StorageAudioFile
  }
  constructor(
    tableName: string,
    type: string,
    fields: hs.HsPropertiesNo$<HSP>,
    recordApi: UgcHeapTableRecordApi,
    tableOptions?: HeapTableOptions<HSP>,
  )
  getSingleton(ctx: RichUgcCtx): Promise<this['T']>
}
declare class UgcHeapTableRepo<HSP extends hs.HsProperties> extends HeapTableRepo<HSP, RichUgcCtx, RichUgcCtx> {
  readonly tableName: string
  protected recordApi: UgcHeapTableRecordApi
  protected hostAccountId: number
  protected runtimeClasses: {
    RefLinkClass: typeof UgcRefLink
    GenericLinkClass: typeof UgcGenericLink
    FileClass: typeof StorageFile
    ImageFileClass: typeof StorageImageFile
    VideoFileClass: typeof StorageVideoFile
    AudioFileClass: typeof StorageAudioFile
  }
  /**
   * UGC table type always start with colon to easily prevent unauthorized access to core heap tables
   * @see constructUgcTableHeapTypeV2
   * :accountID suffix in type allows preventing naming conflicts when importing a heap table definition
   *  from another account
   */
  constructor(
    tableName: string,
    fields: hs.HsPropertiesNo$<HSP>,
    recordApi: UgcHeapTableRecordApi,
    hostAccountId: number,
    tableOptions?: HeapTableOptions<HSP>,
  )
  getSingleton(ctx: RichUgcCtx): Promise<this['T']>
  updateSingleton(ctx: RichUgcCtx, data: hs.HsCreateInputObject<HSP>): Promise<this['T']>
  resetSingleton(ctx: RichUgcCtx): Promise<this['T']>
}
declare type UgcHeapTableRecordApi = HeapTableRecordApi<RichUgcCtx, RichUgcCtx> & {
  pluginAppInfo?: UgcPluginAppVmInfo
  tableNsType: HeapTableNsType
}
declare type User2 = HeapObjectBaseV2 & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
interface UgcCtxPluginApp extends UgcPluginAppUrlInfo {
  type: 'UgcPlugin'
  appId: number
  callingAcc: UgcCtxAccount
  hostAccUser1?: UgcCtxUser1
  hostAccUser2?: UgcCtxUser2 | SerializedSmartUser
}
interface UgcPluginAppUrlInfo {
  appSlug: string
  /** path to the application root directory */
  directoryPath: string
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
declare type AnyObject = Record<string, unknown>
declare type FilterObject<T> =
  | FilterSingleObject<T>
  | TopAndOperator<T>
  | TopOrOperator<T>
  | TopNotOperator<T>
  | NoopOperator
declare type FilterSingleObject<T> = {
  [K in keyof T]?: FilterRighthand<T[K]>
}
declare type TopAndOperator<T> = {
  $and: Array<FilterObject<T>>
}
declare type TopOrOperator<T> = {
  $or: Array<FilterObject<T>>
}
declare type TopNotOperator<T> = {
  $not: FilterObject<T>
}
declare type FilterRighthand<V> =
  | null
  | V
  | Array<V>
  | Operator<V>
  | FilterSingleObject<V>
  | (V extends Date ? DateHint : never)
declare type Operator<V> =
  | GtOperator<V>
  | GteOperator<V>
  | LtOperator<V>
  | LteOperator<V>
  | HasOperator<V>
  | IncludesOperator<V>
  | NotOperator<V>
  | AndOperator<V>
  | OrOperator<V>
  | IlikeOperator<V>
  | NoopOperator
declare type GtOperator<V> = {
  $gt: V
}
declare type GteOperator<V> = {
  $gte: V
}
declare type LtOperator<V> = {
  $lt: V
}
declare type LteOperator<V> = {
  $lte: V
}
declare type IlikeOperator<V> = V extends string
  ? {
      $ilike: V
    }
  : never
declare type HasOperator<V> = {
  $has: V extends AnyObject ? keyof V : never
}
declare type IncludesOperator<V> = {
  $includes:
    | ArrayElement<V>
    | {
        $any: ArrayElement<V>[]
      }
    | {
        $all: ArrayElement<V>[]
      }
}
declare type NoopOperator = {
  $noop: unknown
}
declare type NotOperator<V> = {
  $not: FilterRighthand<V>
}
declare type AndOperator<V> = {
  $and: Array<FilterRighthand<V>>
}
declare type OrOperator<V> = {
  $or: Array<FilterRighthand<V>>
}
declare type DateHint = {
  $date: string
}
declare type ArrayElement<V> = V extends unknown[] ? V[number] : never
/**
 * Common type for any heap table record (HeapObject)
 */
export declare type HeapObject = Pick<hs.HeapObjectBaseV2, 'id' | 'heapType' | 'createdAt' | 'updatedAt'> & {
  createdBy: UgcRefLink<User2> | null
  updatedBy: UgcRefLink<User2> | null
}
export declare const Heap: {
  /**
   * Main heap-table definition constructor.
   *
   * Third argument (host account ID) is provided (appended) by transpiler during build.
   * If it's not, that means edge case not covered by the transpiler and should be fixed.
   * @see tsHeapTablesTransformer
   * @see appendAccountIdToHeapTable
   */
  Table<HSP extends hs.HsProperties, X extends string>(
    tableName: UgcHeapTableName<X>,
    fields: hs.HsPropertiesNo$<HSP>,
    tableOptions?: HeapTableOptions<HSP> | undefined,
  ): UgcHeapTableRepo<HSP>
  ReadOnlyTable<HSP_1 extends hs.HsProperties>(repo: UgcHeapTableRepo<HSP_1>): UgcReadOnlyHeapTableRepo<HSP_1>
  AppHostTable<HSP_2 extends hs.HsProperties>(repo: UgcHeapTableRepo<HSP_2>): UgcHeapTableRepo<HSP_2>
  GenericLink(options?: Partial<hs.HsLinkOptions>): hs.HsGenericLink
  RefLink: typeof RefLink
  UserRefLink(options?: hs.HsLinkOptions): hs.HsRefLink<UgcSmartUser>
  Any<T = any>(options?: hs.HsCustomOptions<T> | undefined): hs.HsAny<T>
  Array<T_1 extends hs.HeapSchema>(items: T_1, options?: hs.HsArrayOptions<T_1> | undefined): hs.HsArray<T_1>
  Boolean(options?: hs.HsCustomOptions<boolean> | undefined): hs.HsBoolean
  DateTime(options?: hs.HsDateTimeOptions | undefined): hs.HsDateTime
  Enum<T_2 extends tb.TEnumType>(
    item: T_2,
    options?: hs.HsCustomOptions<T_2[keyof T_2]> | undefined,
  ): hs.HsEnum<tb.TEnumKey<T_2[keyof T_2]>[]>
  File(options?: hs.HsCustomMetaOption | undefined): hs.HsFile
  ImageFile(options?: hs.HsCustomMetaOption | undefined): hs.HsImageFile
  VideoFile(options?: hs.HsCustomMetaOption | undefined): hs.HsVideoFile
  AudioFile(options?: hs.HsCustomMetaOption | undefined): hs.HsAudioFile
  Integer(options?: hs.HsNumberOptions | undefined): hs.HsInteger
  Intersect<T_3 extends hs.HsIntersectable[]>(
    items: [...T_3],
    options?: hs.HsIntersectOptions<T_3> | undefined,
  ): hs.HsIntersect<T_3>
  KeyOf<T_4 extends hs.HsObject<hs.HsProperties>>(
    object: T_4,
    options?: hs.HsCustomOptions<hs.SelectablePropertyKeys<T_4>> | undefined,
  ): hs.HsKeyOf<hs.SelectablePropertyKeys<T_4>[]>
  Literal<T_5 extends tb.TValue>(value: T_5, options?: hs.HsCustomMetaOption | undefined): hs.HsLiteral<T_5>
  Money(options?: hs.HsMoneyOptions | undefined): hs.HsMoney
  NonRequired<T_6 extends hs.HeapSchema>(item: T_6, dflt: tb.Static<T_6>): hs.HsNonRequired<T_6>
  Null(options?: hs.HsCustomMetaOption | undefined): hs.HsNull
  Number(options?: hs.HsNumberOptions | undefined): hs.HsNumber
  Object<T_7 extends hs.HsProperties>(
    properties: hs.HsPropertiesNo$<T_7>,
    options?: hs.HsObjectOptions<T_7> | undefined,
  ): hs.HsObject<T_7>
  Omit<T_8 extends hs.HsObject<hs.HsProperties>, K extends hs.SelectablePropertyKeys<T_8>[]>(
    object: T_8,
    keys: [...K],
    options?: hs.HsObjectOptions<Omit<hs.SelectableProperties<T_8>, K[number]>> | undefined,
  ): hs.HsObject<Omit<hs.SelectableProperties<T_8>, K[number]>>
  Optional<T_9 extends hs.HeapSchema>(item: T_9): hs.HsOptional<T_9>
  Partial<T_10 extends hs.HsObject<hs.HsProperties>>(
    object: T_10,
    options?: hs.HsCustomOptions<tb.StaticObject<hs.StaticPartial<T_10['properties']>>> | undefined,
  ): hs.HsObject<hs.StaticPartial<T_10['properties']>>
  Pick<T_11 extends hs.HsObject<hs.HsProperties>, K_1 extends hs.SelectablePropertyKeys<T_11>[]>(
    object: T_11,
    keys: [...K_1],
    options?: hs.HsObjectOptions<Pick<hs.SelectableProperties<T_11>, K_1[number]>> | undefined,
  ): hs.HsObject<Pick<hs.SelectableProperties<T_11>, K_1[number]>>
  Record<K_2 extends hs.HsRecordKey, T_12 extends hs.HeapSchema>(
    key: K_2,
    value: T_12,
    options?: hs.HsRecordOptions<tb.StaticRecord<K_2, T_12>> | undefined,
  ): hs.HsRecord<K_2, T_12>
  RegEx(regex: RegExp, options?: hs.HsCustomOptions<string> | undefined): hs.HsString<string>
  Required<T_13 extends hs.HsObject<hs.HsProperties>>(
    object: T_13,
    options?: hs.HsObjectOptions<tb.StaticObject<hs.StaticRequired<T_13['properties']>>> | undefined,
  ): hs.HsObject<hs.StaticRequired<T_13['properties']>>
  String<S extends string = string>(options?: hs.HsStringOptions | undefined): hs.HsString<S>
  Tuple<T_14 extends hs.HeapSchema[]>(
    items: [...T_14],
    options?: hs.HsCustomOptions<tb.StaticTuple<T_14>> | undefined,
  ): hs.HsTuple<T_14>
  Undefined(options?: hs.HsCustomMetaOption | undefined): hs.HsUndefined
  Union<T_15 extends (hs.HsUnionable | hs.HsUnion<hs.HsUnionable[]>)[]>(
    items: [...T_15],
    options?: hs.HsCustomOptions<tb.StaticUnion<T_15>> | undefined,
  ): hs.HsUnion<T_15>
  Unknown(options?: hs.HsCustomOptions<unknown> | undefined): hs.HsUnknown
  Nullable<T_16 extends hs.HsUnionable | hs.HsUnion<hs.HsUnionable[]>>(
    type: T_16,
  ): hs.HsNonRequired<hs.HsUnion<[T_16, hs.HsNull]>>
  NonEmptyString(
    options?: (Pick<tb.StringOptions<never>, 'maxLength'> & hs.HsCustomOptions<string>) | undefined,
  ): hs.HsString<string>
  Currency(options?: hs.HsCustomOptions<import('core/heap/v2/types').Currency> | undefined): hs.HsString<string>
}
declare function RefLink<T extends Record<string, unknown>>(
  tableName: string,
  options?: Partial<hs.HsLinkOptions>,
): hs.HsRefLink<T>
declare function RefLink<T extends hs.HsProperties>(
  repo: UgcAnyHeapTableRepo<T>,
  options?: Partial<hs.HsLinkOptions>,
): hs.HsRefLink<hs.HsRuntime<hs.HsObject<T & hs.HeapObjectBaseSchema>>>
export declare type HeapTableRepo<HSP extends hs.HsProperties = hs.HsProperties> = UgcHeapTableRepo<HSP>
declare const tbKinds: {
  readonly AnyKind: typeof tb.AnyKind
  readonly ArrayKind: typeof tb.ArrayKind
  readonly BooleanKind: typeof tb.BooleanKind
  readonly EnumKind: typeof tb.EnumKind
  readonly IntegerKind: typeof tb.IntegerKind
  readonly IntersectKind: typeof tb.IntersectKind
  readonly KeyOfKind: typeof tb.KeyOfKind
  readonly LiteralKind: typeof tb.LiteralKind
  readonly NullKind: typeof tb.NullKind
  readonly NumberKind: typeof tb.NumberKind
  readonly ObjectKind: typeof tb.ObjectKind
  readonly RecordKind: typeof tb.RecordKind
  readonly StringKind: typeof tb.StringKind
  readonly TupleKind: typeof tb.TupleKind
  readonly UndefinedKind: typeof tb.UndefinedKind
  readonly UnknownKind: typeof tb.UnknownKind
  readonly UnionKind: typeof tb.UnionKind
}
/**
 * Schema-related types and symbols to help in introspection of table schema
 */
export declare const schema: typeof hs & typeof tbKinds
export declare function getRefLinkTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
  ctx: RichUgcCtx,
  schema: hs.HsRefLink<AnyObject>,
): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
export declare function getAccountTablesInfo(ctx: RichUgcCtx): Promise<UgcHeapRegistryLocalTable[]>
export declare function getAccountTableByName<HSP extends hs.HsProperties = hs.HsProperties>(
  ctx: RichUgcCtx,
  tableName: string,
): Promise<UgcHeapTableRepo<HSP>>
/**
 * Starts SERIALIZABLE transaction and injects the transaction ID into the given ctx and passes it to the callback
 *  so all heap operations inside the callback using that ctx will be performed inside the transaction.
 * The transaction is committed after the given callback is run and "awaited"
 *
 * This function-cretated transaction works only for CALLING-ACCOUNT-HOSTED tables
 */
export declare function serializableTransaction<T>(ctx: RichUgcCtx, fn: (ctx: RichUgcCtx) => Promise<T>): Promise<T>
/**
 * Starts SERIALIZABLE transaction and injects the transaction ID into the given ctx and passes it to the callback
 *  so all heap operations inside the callback using that ctx will be performed inside the transaction.
 * The transaction is committed after the given callback is run and "awaited"
 *
 * This function-cretated transaction works only for APP-ACCOUNT-HOSTED tables
 */
export declare function appHostSerializableTransaction<T>(
  ctx: RichUgcCtx,
  fn: (ctx: RichUgcCtx) => Promise<T>,
): Promise<T>
declare type UgcHeapTableName<X> = X extends `${string}:${string}` ? never : X
export declare function prefetchFields<T>(ctx: RichUgcCtx, records: Array<T>, fields: Array<keyof T>): Promise<void>
export {
  Currency,
  GenericLinkJson,
  HeapObjectJson,
  HeapOrderByV2 as HeapTableOrder,
  HeapRecordFilter as HeapTableWhere,
  Money,
  MoneyJson,
} from 'core/heap/v2/types'
export type {
  GenericLinkInputJson,
  HsCreateInput,
  HsFilterInput,
  HsRuntime,
  HsUpdateInput,
} from 'core/heap/v2/heapSchemaTypes'

export { UgcGenericLink as GenericLink, UgcRefLink as RefLink }

export {}
