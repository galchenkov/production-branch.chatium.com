/// <reference types="node" />

import { Static } from '@sinclair/typebox'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import {
  HeapObjectBaseSchema,
  HeapObjectBaseV2,
  HeapSchema,
  HsFilterInput,
  HsFilterInputObject,
  HsObject,
  HsProperties,
  HsProperty,
} from 'core/heap/v2/heapSchemaTypes'
import { HeapOrderByV2, HeapRecordFilter, HeapRecordSelectOptions } from 'core/heap/v2/types'
import {
  ApiCallAction,
  ApiCallErrorResponse,
  ApiCallSuccessResponse,
  AttachMediaAction,
  ChatMessage,
  ChatProps,
  ChatiumAction,
  ChatiumActions,
  QueryParamsOption,
  apiCall,
  navigate,
} from 'lib/chatium-json'
import { Icon, StatusIcon, TuneHttpHeadersResponse, VideoSize } from 'lib/chatium-json/v1'
import {
  AudioBlock,
  BackgroundGradientStyle,
  BorderStyle,
  CommonIconStateStyle,
  DesktopLayout,
  IconProps,
  IconScaleStyle,
  IconTextStyle,
  ImageBlock,
  PlainIconName,
  ScreenErrorResponseV2,
  ScreenPropsV2,
  ScreenSuccessResponseV2,
  ShadowStyle,
  SimpleBgColorStyle,
  SmartIconProps,
  VideoBlock,
} from 'lib/chatium-json/v2'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'

declare type OrderByDefinition<T> = SingleOrderBy<T> | Array<SingleOrderBy<T>>
declare type SortDirection =
  | 'asc'
  | 'desc'
  | 'asc nulls first'
  | 'asc nulls last'
  | 'desc nulls first'
  | 'desc nulls last'
declare type ValueTypeHint = '$string' | '$number' | '$date' | '$boolean'
declare type SingleOrderBy<T> = (keyof T & string) | ObjectOrderVariant<T>
declare type ObjectOrderVariant<T> = {
  [Field in keyof T & string]?: SingleOrderByValue<T[Field]>
}
declare type SingleOrderByValue<V> = V extends object
  ? ObjectOrderVariant<V>
  : SortDirection | ValueTypeHint | [ValueTypeHint, SortDirection]
declare type JSONValue = string | number | boolean | null | JSONValue[] | JSONObject
declare type JSONObject = {
  [key: string]: JSONValue
}
declare type JSONInputValue = string | number | boolean | null | JSONInputValue[] | JSONInputObject | undefined
declare type JSONInputObject = {
  [key: string]: JSONInputValue
}
declare type PublicFieldsOfClass<T> = {
  [Property in keyof T]: T[Property]
}
declare class MessageHelperClass {
  id: string
  account_id: number
  feed_id: number
  external_id: string | null
  origin_id: string | null
  origin_type: string | null
  type: MessageType
  text: string | null
  as_feed: boolean
  reply_to: string | null
  files: MessageFile[] | null
  sticker: MessageSticker | null
  data:
    | JSONInputObject
    | {
        blocks: JSONValue[]
      }
    | ChangeMessageData
    | null
  reactions: Record<
    string,
    Array<{
      userId: HeapId
    }>
  > | null
  created_at: Date
  updated_at: Date
  created_by: string
  updated_by: string
  is_deleted: boolean
  constructor(
    id: string,
    account_id: number,
    feed_id: number,
    external_id: string | null,
    origin_id: string | null,
    origin_type: string | null,
    type: MessageType,
    text: string | null,
    as_feed: boolean,
    reply_to: string | null,
    files: MessageFile[] | null,
    sticker: MessageSticker | null,
    data:
      | JSONInputObject
      | {
          blocks: JSONValue[]
        }
      | ChangeMessageData
      | null,
    reactions: Record<
      string,
      Array<{
        userId: HeapId
      }>
    > | null,
    created_at: Date,
    updated_at: Date,
    created_by: string,
    updated_by: string,
    is_deleted: boolean,
  )
}
declare type Message = PublicFieldsOfClass<MessageHelperClass>
declare type ChangeMessageData = {
  action: string
  messageId: string
}
declare type MessageType = 'Message' | 'System' | 'Change' | 'Blocks'
declare const MessageType: {
  readonly Message: MessageType
  readonly System: MessageType
  readonly Change: MessageType
  readonly Blocks: MessageType
}
declare type MessageFile = {
  url: string
  hash: string
  meta: {
    mime: string
    size: number
    width?: number
    height?: number
    duration?: number
    name?: string
    extra?: string
  }
}
declare type MessageSticker = {
  url: string
  previewUrl?: string
  emoji?: string[]
}
declare type DftTemplate = DftOp[] | string
declare type DftOp = string | DftPlaceable
declare type DftPlaceable = [string] | [string, string]
declare type DynVar = string | number | boolean
declare type DftTranslation = DftTemplate | DftComplexTranslation
declare type DftComplexTranslation = {
  $msg: DftTemplate
} & DftPlaceableTranslations
declare type DftPlaceableTranslations = {
  [key: string]: DftTemplate | DftSelector
}
declare type DftSelector = {
  $val?: DynVar
  $pluralType?: Intl.PluralRulesOptions['type']
} & Record<string | number, DftTemplate | number>
declare type LangBundle = LangBundleKeys & {
  lang: string
}
declare type LangBundleKeys = Map<string, LangBundleMessage>
declare type LangBundleMessage = Map<string, DftTranslation> | DftTranslation
interface TranslateFn {
  (key: string, args?: TranslateArgs): string
  (key: string | undefined, args?: TranslateArgs): string | undefined
  (key: string | null, args?: TranslateArgs): string | null
  (key: TranslationKey, args?: DynamicTranslateArgs): string
  (key: TranslationKey | undefined, args?: DynamicTranslateArgs): string | undefined
  (key: TranslationKey | null, args?: DynamicTranslateArgs): string | null
  (key: TranslationKey | string, args?: TranslateArgs): string
  <T extends null | undefined>(key: null | undefined, args?: TranslateArgs): T
}
declare type TranslationKey<T extends string = string> = [T, StaticTranslateArgs | undefined]
declare type TranslateArgs = {
  [key: string]: DynVar | InCodeSelector | bigint
} & {
  $ns?: string
}
declare type StaticTranslateArgs = {
  [key: string]: StaticInCodeSelector | string
} & {
  $ns?: string
}
declare type DynamicTranslateArgs = {
  [key: string]: DynVar
}
declare type InCodeSelector = {
  $val?: DynVar
} & StaticInCodeSelector
declare type StaticInCodeSelector = {
  $pluralType?: Intl.PluralRulesOptions['type']
  $other?: string | number
} & Record<string | number, DynVar>
interface LocaleCtx extends LangCtx {
  t: TranslateFn
  tt: TranslateFn
  timeZone: string
  formatNumber: (value: number, options?: ImprovedNumberFormatOptions) => string
}
declare type Lang = string
interface LangCtx {
  lang: Lang
}
interface ImprovedNumberFormatOptions extends Intl.NumberFormatOptions {
  style?: 'decimal' | 'currency' | 'percent'
  currencyDisplay?: 'symbol' | 'code' | 'name'
}
declare type TimeUnit =
  | 'milliseconds'
  | 'seconds'
  | 'minutes'
  | 'hours'
  | 'days'
  | 'weeks'
  | 'months'
  | 'quarters'
  | 'years'
declare type Alias<T> = T & {
  ['??']?: never
}
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface UgcJobScheduleParams {
  allowRetry?: boolean
}
declare type WebOrUgcHook<P, R> = string & {
  p: P
  r: R
}
declare type MetricEventJson = JSONInputObject &
  Omit<MetricEventRecord, 'ts' | 'user_expires_at'> & {
    ts: string
    user_expires_at?: string | null
  }
interface MetricEventRecord {
  sign?: number
  uid?: string
  sid?: string
  sid_duration?: number
  inferred_uid?: boolean
  inferred_sid?: boolean
  gc_visit_id?: number
  gc_visitor_id?: number
  gc_session_id?: number
  account_id: number
  account_type: AccountType
  url: string
  referer?: string
  user_agent?: string
  ip?: string
  title?: string
  screen_width?: number
  screen_height?: number
  screen_pixel_ratio?: number
  location_country?: string
  location_region?: string
  location_time_zone?: string
  location_city?: string
  location_coordinates_latitude?: number
  location_coordinates_longitude?: number
  ua_client_type?: string
  ua_client_name?: string
  ua_client_version?: string
  ua_device_type?: string
  ua_device_brand?: string
  ua_device_model?: string
  ua_os_name?: string
  ua_os_version?: string
  ua_os_platform?: string
  ua_bot_name?: string
  ua_bot_category?: string
  os_name?: string
  device_name?: string
  request_type: 'screen' | 'apiCall' | 'get' | 'post'
  auth_id?: number
  auth_type?: string
  auth_key?: string
  auth_first_name?: string
  auth_last_name?: string
  auth_lang?: string
  user_id?: string
  user_type?: 'Anonymous' | 'Real' | 'Bot'
  user_roles?: string[]
  user_account_role?: string
  user_status?: string
  user_expires_at?: Date | null
  user_first_name?: string
  user_last_name?: string
  user_icon_image?: string
  user_phone?: string
  user_email?: string
  user_platforms?: string[]
  session_id?: string
  session_email?: string
  session_phone?: string
  fcm_token?: string
  ts: Date
  ts64?: number
  funnel?: string
  funnel_node?: string
  funnel_node_from?: string
  utm_source?: string
  utm_content?: string
  utm_medium?: string
  utm_campaign?: string
  utm_term?: string
  action?: string
  action_params?: string
  action_param1?: string
  action_param2?: string
  action_param3?: string
  action_param1_float?: number
  action_param2_float?: number
  action_param3_float?: number
  action_param4_float?: number
  action_param1_int?: number
  action_param2_int?: number
  action_param3_int?: number
  action_param1_arrstr?: string[]
  action_param2_arrstr?: string[]
  action_param3_arrstr?: string[]
  action_param1_uint32arr?: number[] | undefined
  keys?: string[]
  values?: string[]
  /**
   * CLRT parsing
   * clrt=t:y_c:{campaign_id}_g:{gbid}_a:{ad_id}_ph:{phrase_id}_k:{keyword}_cr:{creative_id}_rt:{retargeting_id}_int:{interest_id}_at:{adtarget_id}_reg:{region_id}_s:{source}_dt:{device_type}
   */
  param_clrt?: string
  clrt_type?: string
  clrt_campaign_id?: string
  clrt_ad_id?: string
}
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare class HeapRecordHelperClass {
  id: HeapId
  idx: number
  account_id: number
  type: HeapObjectType
  data: object | null
  created_by: HeapId | null | undefined
  created_at: Date
  updated_by: HeapId | null | undefined
  updated_at: Date
  constructor(
    id: HeapId,
    idx: number,
    account_id: number,
    type: HeapObjectType,
    data: object | null,
    created_by: HeapId | null | undefined,
    created_at: Date,
    updated_by: HeapId | null | undefined,
    updated_at: Date,
  )
}
declare type HeapRecord = PublicFieldsOfClass<HeapRecordHelperClass>
interface HeapObjectBase {
  id: HeapId
  idx: number
  heapType: HeapObjectType
  createdAt: Date
  updatedAt: Date
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type HeapFieldName<HD extends HeapData> = keyof EraseHD<HD> & string
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type EraseRefLink<RL extends RefLink<HeapData>> = Omit<RL, '~~ref~link~tag~~'>
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObject<HD extends HeapData> = HeapObjectBase & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
declare type HeapId = string
declare type HeapObjectType = string
interface FieldMeta<JT> {
  default?: JT
  required?: boolean
}
interface IntMeta extends FieldMeta<number> {
  type: 'int'
}
interface DateMeta extends FieldMeta<Date> {
  type: 'datetime'
}
interface TextMeta<JT> extends FieldMeta<JT> {
  type: 'text'
}
interface BooleanMeta extends FieldMeta<boolean> {
  type: 'boolean'
}
interface RefLinkMeta<JT> extends FieldMeta<JT> {
  type: 'link'
  targetType: HeapObjectType
}
interface GenericLinkMeta extends FieldMeta<HeapObjectBase> {
  type: 'genLink'
}
interface EnumMeta<JT> extends FieldMeta<JT> {
  type: 'enum'
  values: string[]
}
interface NumEnumMeta<JT> extends FieldMeta<JT> {
  type: 'nenum'
  values: number[]
}
interface ObjectMeta<JT> extends FieldMeta<JT> {
  type: 'object'
}
declare type HeapFieldMetas<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: JsFieldTypeToMeta<HD[K]>
}
declare type JsFieldTypeToMeta<JT> = JT extends number
  ? IntMeta | NumEnumMeta<JT>
  : JT extends Date
  ? DateMeta
  : JT extends string
  ? TextMeta<JT> | EnumMeta<JT>
  : JT extends boolean
  ? BooleanMeta
  : JT extends GenericLink
  ? GenericLinkMeta
  : JT extends RefLink<HeapData>
  ? RefLinkMeta<JT>
  : JT extends object
  ? ObjectMeta<JT>
  : never
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
interface VideoInfo {
  hash: string
  url: string | null
  hlsUrl: string | undefined
  mp4Url: string | undefined
  status: FileServiceResponse['status']
  progress: number
  imageUrl: string
  /** @deprecated always undefined */
  videoSize: VideoSize | undefined
  videoAspectRatio: [number, number] | undefined
}
interface FileServiceResponse {
  status: 'done' | 'processing' | 'error'
  width_aspect_ratio?: number
  height_aspect_ratio?: number
  progress?: number
  kinescopeVideoId?: string | number
  integrosVideoId?: string | number
  cloudflareVideoId?: string | number
}
declare abstract class StorageFile implements IStorageFile {
  readonly hash: string
  protected abstract readonly fileServiceHost: string
  constructor(hash: string)
  toJSON(): string
  get type(): HashMediaType
  get downloadUrl(): string
}
interface FileClass {
  new (hash: string): IStorageFile
}
interface IStorageFile {
  hash: string
  type: HashMediaType
  downloadUrl: string
  toJSON(): string
}
declare abstract class StorageFileWithSizes extends StorageFile implements IStorageFileWithSizes {
  #private
  get width(): number
  get widthMaybe(): number | undefined
  get height(): number
  get heightMaybe(): number | undefined
  get sizes(): {
    width: number
    height: number
  }
  get sizesMaybe():
    | {
        width: number
        height: number
      }
    | undefined
}
interface IStorageFileWithSizes extends IStorageFile {
  width: number
  widthMaybe: number | undefined
  height: number
  heightMaybe: number | undefined
  sizes: {
    width: number
    height: number
  }
  sizesMaybe:
    | {
        width: number
        height: number
      }
    | undefined
}
declare abstract class StorageImageFile extends StorageFileWithSizes implements IStorageImageFile {
  get type(): 'image'
  getThumbnailUrl(width?: number, height?: number): string
  /**
   * Returns the image's URL and sizes in format accepted by src property of <image> block.
   */
  getThumbnailSrc(width?: number, height?: number): ImageBlock['src']
}
interface ImageFileClass {
  new (hash: string): IStorageImageFile
}
interface IStorageImageFile extends IStorageFileWithSizes {
  getThumbnailUrl(width?: number, height?: number): string
  getThumbnailSrc(width?: number, height?: number): ImageBlock['src']
}
declare abstract class StorageVideoFile extends StorageFileWithSizes implements IStorageVideoFile {
  #private
  get type(): 'video'
  getThumbnailUrl(width?: number, height?: number, offsetSeconds?: 'auto' | number): string
  /**
   * Returns the video's frame thumbnail URL and sizes in format accepted by src property of <image> block.
   */
  getThumbnailSrc(width?: number, height?: number, offsetSeconds?: 'auto' | number): ImageBlock['src']
  get duration(): number
  get durationMaybe(): number | undefined
  get videoSrc(): Promise<VideoBlock['src']>
  get status(): Promise<'done' | 'processing' | 'error'>
  get progress(): Promise<number>
  protected abstract getVideoInfo(): Promise<VideoInfo>
  private get videoInfo()
}
interface VideoFileClass {
  new (hash: string): IStorageVideoFile
}
interface IStorageVideoFile extends IStorageFileWithSizes {
  duration: number
  durationMaybe: number | undefined
  videoSrc: Promise<VideoBlock['src']>
  status: Promise<'done' | 'processing' | 'error'>
  progress: Promise<number>
  getThumbnailUrl(width?: number, height?: number, offsetSeconds?: 'auto' | number): string
  getThumbnailSrc(width?: number, height?: number, offsetSeconds?: 'auto' | number): ImageBlock['src']
}
declare abstract class StorageAudioFile extends StorageFile implements IStorageAudioFile {
  #private
  get type(): 'audio'
  get duration(): number
  get durationMaybe(): number | undefined
  get audioSrc(): AudioBlock['src']
}
interface AudioFileClass {
  new (hash: string): IStorageAudioFile
}
interface IStorageAudioFile extends IStorageFile {
  duration: number
  durationMaybe: number | undefined
  audioSrc: AudioBlock['src']
}
interface HeapRuntimeClasses {
  RefLinkClass: RefLinkClass
  GenericLinkClass: GenericLinkClass
  FileClass: FileClass
  ImageFileClass: ImageFileClass
  VideoFileClass: VideoFileClass
  AudioFileClass: AudioFileClass
}
declare type HeapLinkInfo =
  | {
      refType: 'RefLink'
      fieldPath: string
      targetType: HeapObjectType
      id: HeapId
    }
  | {
      refType: 'GenericLink'
      fieldPath: string
      id: HeapId
    }
  | {
      fieldPath: string
      id: null
    }
interface HeapTableRecordApi<ReadCtx, WriteCtx> {
  findHeapRecordByTypeAndId(ctx: ReadCtx, type: HeapObjectType, id: HeapId): Promise<HeapRecord | null>
  findHeapRecordsByTypeAndIds(ctx: ReadCtx, type: HeapObjectType, ids: HeapId[]): Promise<HeapRecord[]>
  queryHeapRecords<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    options?: HeapRecordSelectOptions<HSP>,
  ): Promise<HeapRecord[]>
  queryHeapRecordIds<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    options?: HeapRecordSelectOptions<HSP>,
  ): Promise<HeapId[]>
  countHeapRecords<HSP extends HsProperties>(
    ctx: ReadCtx,
    type: HeapObjectType,
    filter?: HeapRecordFilter<HSP> | null,
  ): Promise<number>
  createHeapRecord<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    linkInfo: HeapLinkInfo[],
    data: Static<HsObject<HSP>> & {
      id?: HeapId
    },
  ): Promise<HeapRecord>
  updateHeapRecordMaybe<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    linkInfo: HeapLinkInfo[],
    patch: Partial<Static<HsObject<HSP>>> & {
      id: HeapId
    },
    optionalFieldsToClear?: Array<keyof HSP>,
  ): Promise<HeapRecord | null>
  createOrUpdateHeapRecordBy<HSP extends HsProperties, K extends HsProperty<HSP>>(
    ctx: WriteCtx,
    type: HeapObjectType,
    uniqKey: K,
    linkInfo: HeapLinkInfo[],
    data: Static<HsObject<HSP>>,
  ): Promise<HeapRecord>
  deleteHeapRecord(ctx: WriteCtx, type: HeapObjectType, id: HeapId, hardDelete: boolean): Promise<HeapRecord | null>
  createOrUpdateSingleton<HSP extends HsProperties>(
    ctx: WriteCtx,
    type: HeapObjectType,
    createLinkInfo: HeapLinkInfo[],
    createData: Static<HsObject<HSP>>,
    updateLinkInfo: HeapLinkInfo[],
    updatePatch: Partial<Static<HsObject<HSP>>>,
    optionalFieldsToClear?: Array<keyof HSP>,
  ): Promise<HeapRecord>
}
declare type HsSelectOptions<HSP extends HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HeapOrderByV2<HSP> | null | undefined
}
declare type HsFilter<HSP extends HsProperties> =
  | HsFilterInputObject<HSP & Pick<HeapObjectBaseSchema, 'id' | 'createdAt' | 'updatedAt' | 'createdBy' | 'updatedBy'>>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTopAndOperator<HSP extends HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends HeapSchema> = HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare abstract class ReadOnlyHeapTableRepo<HSP extends hs.HsProperties, ReadCtx, WriteCtx = ReadCtx> {
  readonly type: HeapObjectType
  protected readonly tableOptions?: HeapTableOptions<HSP> | undefined
  readonly schema: hs.HsObject<HSP>
  readonly T: hs.HsFullObjectRuntime<HSP>
  readonly JsonT: hs.HsObjectStatic<HSP>
  readonly PropsT: HSP
  readonly PatchT: Partial<hs.HsUpdateInputObject<HSP>>
  readonly CreateInputT: hs.HsCreateInputObject<HSP> & {
    id?: HeapId
  }
  /**
   * Low-level heap record API differs for core backend and UGC implementations
   * This helps to share a lot of high-level code written in this class for UGC/core implementations of the heap table
   */
  protected abstract recordApi: HeapTableRecordApi<ReadCtx, WriteCtx>
  /**
   * Runtime RefLink instance implementations differ for core backend and UGC in terms of
   *  how they implement .get() method, when only a string type repo is provided.
   *  Global registries of heap-table repos are organized differently
   */
  protected abstract runtimeClasses: HeapRuntimeClasses
  constructor(type: HeapObjectType, fields: hs.HsPropertiesNo$<HSP>, tableOptions?: HeapTableOptions<HSP> | undefined)
  /**
   * Type guard to easily recognize heap objects belonging to this table
   * May be useful in combination with generic links
   */
  isMyRecord(obj: unknown): obj is this['T']
  getById(ctx: ReadCtx, id: HeapId): Promise<this['T']>
  getRecordTitleById(ctx: ReadCtx, id: HeapId): Promise<string>
  /**
   * Generic method to get human-readable title of the record.
   * May be customized by tableOptions.getRecordTitleSync.
   * By default, it tries to use 'title' or 'name' fields, or just '#<id>'.
   */
  getRecordTitle(_ctx: ReadCtx, row: this['T']): Promise<string>
  findById(ctx: ReadCtx, id: HeapId): Promise<this['T'] | null>
  findByIds(ctx: ReadCtx, ids: HeapId[]): Promise<this['T'][]>
  findAll(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<this['T'][]>
  findAllIds(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<HeapId[]>
  findBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'][]>
  findOneBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'] | null>
  countBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<number>
  /**
   * Returns a singleton row of this table or a stub record with default values.
   * Treats the whole table as a single-row "singleton".
   * All fields of this table must be Heap.NonRequired, Heap.Nullable or Heap.Optional,
   *  or at least have a "default" option defined.
   */
  getSingleton(ctx: ReadCtx): Promise<this['T']>
  protected getDefaultSingleton(): this['T']
  protected rawToObject: (hr: HeapRecord) => this['T']
  get customMeta(): NonNullable<hs.HsCustomMetaOption['customMeta']>
  /**
   * Augments and converts where and order options according to the schema
   * DRY
   */
  private prepareSelectOptions
}
declare abstract class HeapTableRepo<HSP extends hs.HsProperties, ReadCtx, WriteCtx> extends ReadOnlyHeapTableRepo<
  HSP,
  ReadCtx,
  WriteCtx
> {
  /**
   * Lazy-cached internal structure helping with detecting absent ref-link values,
   *  meaning that ref-link-tracking should be cleared for the respective fields.
   */
  private cachedLinkPaths
  private validateFn
  private validateUpdateFn
  create(ctx: WriteCtx, data: this['CreateInputT']): Promise<this['T']>
  update(
    ctx: WriteCtx,
    patch: Partial<hs.HsUpdateInputObject<HSP>> & {
      id: HeapId
    },
  ): Promise<this['T']>
  updateMaybe(
    ctx: WriteCtx,
    patch: this['PatchT'] & {
      id: HeapId
    },
  ): Promise<this['T'] | null>
  createOrUpdateBy<K extends hs.HsProperty<HSP>>(
    ctx: WriteCtx,
    uniqKey: K,
    data: hs.HsCreateInputObject<HSP> & Record<K, CreateOrUpdateUniqValue<HSP, K>>,
  ): Promise<this['T']>
  delete(ctx: WriteCtx, id: HeapId, hard?: boolean): Promise<this['T'] | null>
  /**
   * Updates a singleton row.
   * If the row doesn't exist, creates (materializes) it with default values
   *  for fields that are not provided in the `data` argument.
   * Fails with DataConsistencyError if there is more than one record in this table.
   * Should be used only with "singleton" tables which are accessed only via getSingleton method.
   * Returns the updated record.
   */
  updateSingleton(ctx: WriteCtx, data: hs.HsCreateInputObject<HSP>): Promise<this['T']>
  /**
   * Deletes a singleton row of the table if it exists.
   * Fails with DataConsistencyError if there is more than one record in this table.
   * Should be used only with "singleton" tables which are accessed only via getSingleton method.
   * Returns a default stub record with default values defined by the table schema.
   */
  resetSingleton(ctx: ReadCtx & WriteCtx): Promise<this['T']>
  /**
   * This hidden method supports defining explicit idx field, which should never be used in usual cases.
   * It's needed only in one case - auto-migration of RefLinks from old getcourse user cache to v2 (Multi) users.
   * @internal
   * @see createNewGcUserWithIdentities
   */
  private _create
  private get validate()
  private get validateUpdate()
  private getLinksPaths
}
interface HeapTableOptions<HSP extends hs.HsProperties> extends hs.HsCustomMetaOption {
  getRecordTitleSync?(record: hs.HsFullObjectRuntime<HSP>): string | null | undefined
}
declare type CreateOrUpdateUniqValue<HSP extends hs.HsProperties, K extends keyof HSP> = Static<HSP[K]> extends
  | string
  | number
  ? hs.HsCreateInput<HSP[K]>
  : never
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends HsProperties = HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>)
  get<R = HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends HsProperties = HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare class AuthHelperClass {
  id: number
  type: AuthType
  key: string
  /**
   * List of account IDs which have this auth registered as a user
   * This field seems redundant because this info can be obtained from Users of each account,
   *   but as every account has its own heap DB, there is no easy way to iterate over accounts for the given auths
   *   without this field.
   */
  accounts: number[]
  avatar: Icon | null
  first_name: string | null
  last_name: string | null
  /**
   * Stores info about which session auth data was merged to which real auth.
   * This is a key for performant detecting when to migrate data without any additional db queries or computations.
   *
   * For type === Session -> map from <account ID> -> list of linked <real auth ID>s
   * For others           -> map from <account ID> -> list of linked <session auth KEY>s
   * @see mergeSessionToRealAuth
   * @see unlinkSessionAuth
   */
  session_links: Record<number, string[] | number[]>
  expires_at: Date | null
  constructor(
    id: number,
    type: AuthType,
    key: string,
    /**
     * List of account IDs which have this auth registered as a user
     * This field seems redundant because this info can be obtained from Users of each account,
     *   but as every account has its own heap DB, there is no easy way to iterate over accounts for the given auths
     *   without this field.
     */
    accounts: number[],
    avatar: Icon | null,
    first_name: string | null,
    last_name: string | null,
    /**
     * Stores info about which session auth data was merged to which real auth.
     * This is a key for performant detecting when to migrate data without any additional db queries or computations.
     *
     * For type === Session -> map from <account ID> -> list of linked <real auth ID>s
     * For others           -> map from <account ID> -> list of linked <session auth KEY>s
     * @see mergeSessionToRealAuth
     * @see unlinkSessionAuth
     */
    session_links: Record<number, string[] | number[]>,
    expires_at: Date | null,
  )
}
declare type Auth = PublicFieldsOfClass<AuthHelperClass>
declare enum AuthType {
  Email = 'Email',
  None = 'None',
  Phone = 'Phone',
  Session = 'Session',
  Inbox = 'Inbox',
  API = 'API',
}
declare type UpdateFields<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: ForUpdate<HD[K]>
}
declare type ForUpdate<T> = T extends GenericLink
  ? HeapObjectBase | HeapId
  : T extends RefLink<HeapData>
  ? HeapObject<EraseRefLink<T>> | HeapId
  : T
declare type MapFilterLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: FilterLinksMap<HD[K]>
}
declare type HeapQueryData<HD extends HeapData> = HeapObjectBase & MapFilterLinks<HD>
declare type HeapQueryFilter<HD extends HeapData> = FilterObject<HeapQueryData<HD>>
declare type HeapOrderBy<HD extends HeapData> = OrderByDefinition<HeapQueryData<HD>>
declare type HeapFindAllOptions<HD extends HeapData> = {
  where?: HeapQueryFilter<HD> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HeapOrderBy<HD> | null | undefined
}
declare type FilterLinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapId
  : T
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare type SessionId = string
declare enum Currency {
  USD = 'USD',
  RUB = 'RUB',
  EUR = 'EUR',
}
interface Money {
  amount: number
  currency: Currency
}
declare type EntityId = string
interface AppPermissions {
  accountApps?:
    | AppPermissionRule
    | ({
        install?: AppWritePermissionRule
        uninstall?: AppWritePermissionRule
      } & NestedPermissionRule)
  accountDomains?: AppPermissionRule
  /**
   * Access to heap-tables owned by the account code itself from the connected app.
   * Useful for generic CRUD/admin application.
   * Shouldn't be given to untrusted third-party apps.
   */
  accountHeap?:
    | AppPermissionRule
    | ({
        tablesList?: AppReadPermissionRule
        tableByName?: AppReadPermissionRule
        tableRows?: AppPermissionRule
      } & NestedPermissionRule)
  accountSettings?:
    | AppPermissionRule
    | ({
        title?: AppPermissionRule
        image?: AppPermissionRule
        lang?: AppPermissionRule
        createdAt?: AppReadPermissionRule
      } & NestedPermissionRule)
  authenticate?:
    | AppWritePermissionRule
    | ({
        Phone?: AppWritePermissionRule
        Email?: AppWritePermissionRule
        TelegramId?: AppWritePermissionRule
      } & NestedWritePermissionRule)
  i18n?:
    | AppPermissionRule
    | ({
        getSupportedTranslationLangs?: AppReadPermissionRule
      } & NestedPermissionRule)
  user?:
    | AppPermissionRule
    | ({
        createBotUser?: AppWritePermissionRule
        accountRole?: AppWritePermissionRule
        username?: AppWritePermissionRule
        lang?: AppWritePermissionRule
        identities?:
          | AppPermissionRule
          | ({
              Phone?: AppPermissionRule
              Email?: AppPermissionRule
              Password?: AppPermissionRule
            } & NestedPermissionRule)
        name?:
          | AppPermissionRule
          | ({
              firstName?: AppPermissionRule
              middleName?: AppPermissionRule
              lastName?: AppPermissionRule
            } & NestedPermissionRule)
        gender?: AppPermissionRule
        birthday?: AppPermissionRule
        image?: AppPermissionRule
      } & NestedPermissionRule)
  metric?:
    | AppPermissionRule
    | ({
        access?: AppPermissionRule
        event?: AppPermissionRule
        eventSubscription: AppPermissionRule
      } & NestedPermissionRule)
}
declare type AppWritePermissionRule = false | 'write'
declare type AppReadPermissionRule = false | 'read'
declare type AppPermissionRule = false | 'read' | 'write'
declare type NestedPermissionRule = {
  all?: AppPermissionRule
}
declare type NestedWritePermissionRule = {
  all?: AppPermissionRule
}
declare type Identity = PublicFieldsOfClass<IdentityHelperClass>
declare class IdentityHelperClass {
  id: string
  account_id: number
  user_id: string
  type: IdentityType
  key: string
  secret: string | null
  last_confirmed_at: Date | null
  is_primary: boolean
  is_blocked: boolean
  created_at: Date
  updated_at: Date
  confirmed_by: AuthProvider[]
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    type: IdentityType,
    key: string,
    secret: string | null,
    last_confirmed_at: Date | null,
    is_primary: boolean,
    is_blocked: boolean,
    created_at: Date,
    updated_at: Date,
    confirmed_by: AuthProvider[],
  )
}
declare type IdentityType =
  | CustomProvidableIdentityType
  | 'Password'
  | 'ApiKey'
  | 'ParentAccountUser'
  | 'DeviceId'
  | 'TechSupport'
  | 'GetcourseId'
declare type CustomProvidableIdentityType = 'Phone' | 'Email' | 'TelegramId'
declare type AuthProvider =
  | 'Device'
  | 'Sms'
  | 'Email'
  | 'Password'
  | 'AnotherSession'
  | 'ParentAccount'
  | 'Getcourse'
  | 'MobileAppPhone'
  | 'MobileAppEmail'
  | 'Github'
  | 'Google'
  | 'Telegram'
  | 'Chatium'
  | string
declare type AuthProviderProps = {
  provider: AuthProvider
  /** additional provider-specific data provided by the provider and stored in the auth log */
  providerData?: Record<string, unknown>
}
declare type PrimaryIdentitiesByUser = Record<HeapId, PrimaryIdentities>
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type ExtendedUserFieldsSupport = Partial<Record<keyof ExtendedUserFields, boolean>>
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObject<UserData>
declare type UgcSystemHeapTableName = 'users'
interface GetMobileAppLinkOptions {
  allowBrowser?: boolean
}
interface MobileAppLinkPrefixes {
  bundleId: string
  custom?: string
  web?: string
}
interface AuthFlowParams {
  backUrl?: string
  fromApiCall?: boolean
  mobileAppLinkPrefixes?: MobileAppLinkPrefixes
}
interface AuthProviderButtonInfo {
  title: string
  onClick: ChatiumActions
  icon?: Pick<SmartIconProps, 'url' | 'name' | 'text' | 'class'> & {
    style?: BackgroundGradientStyle &
      BorderStyle &
      CommonIconStateStyle &
      IconScaleStyle &
      IconTextStyle &
      ShadowStyle &
      SimpleBgColorStyle
  }
}
declare type SerializableLangTranslations = Record<number, readonly [AccountLangTranslations[], Lang]>
declare type AccountLangTranslations = [Lang, Record<string, Record<string, DftTranslation>>]
interface WithAggregateOptimization {
  hasAggregateOptimization: true
}
interface WithAggregateHit {
  aggregateHit: boolean
}
declare type UgcInternalRequestPayload =
  | UgcAuthProviderHookGetButtonsRequest
  | UgcGetExtendedUserInfoRequest
  | UgcUpdateExtendedUserInfoRequest
  | UgcFindUserIdsByFuzzyTextInExtendedInfoRequest
  | UgcGetExtendedUserFieldsSupportRequest
  | UgcTriggerIapUpdatedByUserHookRequest
  | UgcTriggerIapUpdatedTxnsHookRequest
  | UgcTriggerRouter404ErrorHookRequest
  | UgcTriggerDistributedHookRequest
  | UgcTriggerMetricEventHookRequest
  | UgcGetEffectiveTranslationsForI18nKeysRequest
  | UgcGetAllI18nTranslationsForLangsRequest
  | UgcGetUntranslatedI18nKeysRequest
interface UgcGetExtendedUserInfoRequest extends AppPermissionsAwareUgcInternalRequest {
  type: 'getExtendedUserInfo'
  usersById: Record<HeapId, UgcCtxUser2>
}
interface UgcGetExtendedUserInfoResponse {
  extendedUserInfoById: Record<HeapId, ExtendedUserInfo>
}
interface UgcUpdateExtendedUserInfoRequest extends AppPermissionsAwareUgcInternalRequest {
  type: 'updateExtendedUserInfo'
  user: UgcCtxUser2
  info: UpdateExtendedUserInfo
}
interface UgcUpdateExtendedUserInfoResponse {
  updatedInfo?: ExtendedUserInfo
}
interface UgcFindUserIdsByFuzzyTextInExtendedInfoRequest extends AppPermissionsAwareUgcInternalRequest {
  type: 'findUserIdsByFuzzyTextInExtendedInfo'
  word: string
}
interface UgcFindUserIdsByFuzzyTextInExtendedInfoResponse {
  userIds: HeapId[]
}
interface UgcGetExtendedUserFieldsSupportRequest {
  type: 'getExtendedUserFieldsSupport'
}
interface UgcGetExtendedUserFieldsSupportResponse {
  result: ExtendedUserFieldsSupport
}
interface UgcTriggerIapUpdatedByUserHookRequest {
  type: 'triggerIapUpdatedByUserHook'
  txnIds: string[]
}
interface UgcTriggerIapUpdatedTxnsHookRequest {
  type: 'triggerIapUpdatedTxnsHook'
  txnIds: string[]
}
interface UgcTriggerIapUpdatedHookResponse {
  hookActive: boolean
}
interface UgcTriggerRouter404ErrorHookRequest extends WithAggregateOptimization, NeedCtxUserBypass {
  type: 'triggerUgcRouter404ErrorHook'
  req: UgcTriggerRouter404ErrorHookRequestPayload
}
interface UgcTriggerRouter404ErrorHookRequestPayload extends WithTimeoutMs {
  method?: string
  headers?: Record<string, string>
  path: string
  query: Record<string, string | string[]>
}
interface UgcTriggerRouter404ErrorHookResponse extends WithAggregateHit {
  response: unknown
}
interface UgcAuthProviderHookGetButtonsRequest extends WithAggregateOptimization {
  type: 'authProviderHookGetButtons'
  enabledProviders: AuthProvider[]
  params: AuthFlowParams
}
interface UgcAuthProviderHookGetButtonsResponse extends WithAggregateHit {
  result?: AuthProviderButtonInfo[]
}
interface UgcTriggerDistributedHookRequest extends WithAggregateOptimization, WithTimeoutMs {
  type: 'triggerDistributedHook'
  hook: string
  payload: JSONInputValue
  method?: string
  useSerializer?: boolean
  /**
   * Caller may decide to pass ctx.auth and ctx.user, by default they are not sent
   * @see runUgcInternalRequest
   * @see needCtxUserBypass
   */
  needCtxUserBypass?: boolean
}
interface UgcTriggerDistributedHookResponse extends WithAggregateHit {
  result?: JSONValue[]
}
interface UgcTriggerMetricEventHookRequest extends WithAggregateOptimization {
  type: 'triggerMetricEventHook'
  event: MetricEventJson
  groupKey: string | null
  params: JSONValue
  method?: string
}
interface UgcGetEffectiveTranslationsForI18nKeysRequest {
  type: 'getEffectiveTranslationsForI18nKeys'
  keys: Array<string | [string, string[]]>
  langs: Lang[]
}
interface UgcGetEffectiveTranslationsForI18nKeysResponse {
  translations: SerializableLangTranslations | null
}
interface UgcGetAllI18nTranslationsForLangsRequest {
  type: 'getAllEffectiveI18nTranslationsForLangs'
  langs: Lang[]
  ifModifiedHash?: string
}
interface UgcGetAllI18nTranslationsForLangsResponse {
  translations: SerializableLangTranslations | null
  hash: string
}
interface UgcGetUntranslatedI18nKeysRequest {
  type: 'getUntranslatedI18nKeys'
  lang: Lang
  keys: string[]
}
interface UgcGetUntranslatedI18nKeysResponse {
  untranslatedKeys: string[]
}
interface WithTimeoutMs {
  timeoutMs?: number | undefined
}
declare type UgcMatchingInternalResponse<T extends UgcInternalRequestPayload> = UgcInternalRequestResultMap[T['type']]
interface UgcInternalRequestResultMap {
  authProviderHookGetButtons: UgcAuthProviderHookGetButtonsResponse
  getExtendedUserInfo: UgcGetExtendedUserInfoResponse
  updateExtendedUserInfo: UgcUpdateExtendedUserInfoResponse
  findUserIdsByFuzzyTextInExtendedInfo: UgcFindUserIdsByFuzzyTextInExtendedInfoResponse
  getExtendedUserFieldsSupport: UgcGetExtendedUserFieldsSupportResponse
  triggerMetricEventHook: WithAggregateHit
  triggerDistributedHook: UgcTriggerDistributedHookResponse
  triggerIapUpdatedByUserHook: UgcTriggerIapUpdatedHookResponse
  triggerIapUpdatedTxnsHook: UgcTriggerIapUpdatedHookResponse
  triggerUgcRouter404ErrorHook: UgcTriggerRouter404ErrorHookResponse
  getEffectiveTranslationsForI18nKeys: UgcGetEffectiveTranslationsForI18nKeysResponse
  getAllEffectiveI18nTranslationsForLangs: UgcGetAllI18nTranslationsForLangsResponse
  getUntranslatedI18nKeys: UgcGetUntranslatedI18nKeysResponse
}
interface AppPermissionsAwareUgcInternalRequest {
  appPermissions?: AppPermissions
}
interface NeedCtxUserBypass {
  needCtxUserBypass: true
}
declare class ParticipantHelperClass {
  id: string
  account_id: number
  feed_id: number
  user_id: HeapId
  read_at: Date | null
  read_message_id: string | null
  role: string
  muted: boolean
  inbox_disabled: boolean
  data: JSONInputObject | null
  created_at: Date
  updated_at: Date
  created_by: string
  updated_by: string
  is_deleted: boolean
  hooks: ParticipantHooks | null
  inbox_extra_data: JSONObject | null
  constructor(
    id: string,
    account_id: number,
    feed_id: number,
    user_id: HeapId,
    read_at: Date | null,
    read_message_id: string | null,
    role: string,
    muted: boolean,
    inbox_disabled: boolean,
    data: JSONInputObject | null,
    created_at: Date,
    updated_at: Date,
    created_by: string,
    updated_by: string,
    is_deleted: boolean,
    hooks: ParticipantHooks | null,
    inbox_extra_data: JSONObject | null,
  )
}
declare type Participant = PublicFieldsOfClass<ParticipantHelperClass>
interface ParticipantHooks {}
declare type UgcParticipant = Pick<Participant, 'id' | 'muted'> & {
  userId: Participant['user_id']
  createdAt: string
  updatedAt: string
  inboxDisabled: Participant['inbox_disabled']
  inboxExtraData: Participant['inbox_extra_data']
}
declare class FeedHelperClass {
  id: number
  uid: string
  account_id: number
  db_shard_id: string
  db_shard_move_state: DbShardMoveState | null
  model_type: string
  /**
   * For old entity-linked feeds - ID of the Heap object matching the entity
   * For new decoupled feeds this field should be renamed to inbox_subject_id -
   *  unique string which helps to detect which inbox item should be updated when the feed is updated
   */
  model_id: string
  title: string | null
  icon: Icon | null
  url: string | null
  status: string | null
  status_icon: StatusIcon | null
  is_actual: boolean
  pinned_message_id: string | null
  last_message_id: string | null
  owner_user_id: string | null
  created_at: Date
  updated_at: Date
  data: JSONObject | null
  hooks: FeedHooks | null
  inbox_extra_data: JSONObject | null
  constructor(
    id: number, // Идентификатор для связи
    uid: string, // Идентификатор для пользователя
    account_id: number,
    db_shard_id: string,
    db_shard_move_state: DbShardMoveState | null,
    model_type: string, // Тим подели кому принадлежит сообщение
    /**
     * For old entity-linked feeds - ID of the Heap object matching the entity
     * For new decoupled feeds this field should be renamed to inbox_subject_id -
     *  unique string which helps to detect which inbox item should be updated when the feed is updated
     */
    model_id: string,
    title: string | null,
    icon: Icon | null,
    url: string | null,
    status: string | null,
    status_icon: StatusIcon | null,
    is_actual: boolean,
    pinned_message_id: string | null, // Прикрепленное сообщение
    last_message_id: string | null, // Последнее сообщение
    owner_user_id: string | null, // Сделано для поиска фида по модели, принадлежащего конкретному юзеру
    created_at: Date,
    updated_at: Date,
    data: JSONObject | null,
    hooks: FeedHooks | null,
    inbox_extra_data: JSONObject | null,
  )
}
declare type Feed = PublicFieldsOfClass<FeedHelperClass>
interface FeedHooks {
  getInboxInfo?: WebOrUgcHook<GetInboxInfoHookParams, InboxInfo>
  getParticipantInboxInfo?: WebOrUgcHook<GetParticipantInboxInfoHookParams, InboxInfo>
}
declare type GetInboxInfoHookParams = {
  feed: InboxInfoHookFeedInfo
  lastMessage: InboxInfoHookMessageInfo | null
  event: 'messagePosted' | 'participantAdded' | 'participantRemove' | 'markAsRead'
}
declare type GetParticipantInboxInfoHookParams = GetInboxInfoHookParams & {
  participant: UgcParticipant
}
declare type InboxInfoHookFeedInfo = Pick<UgcFeed, 'id' | 'inboxExtraData'>
declare type InboxInfoHookMessageInfo = Pick<
  Message,
  'id' | 'type' | 'text' | 'as_feed' | 'reply_to' | 'files' | 'data' | 'created_by'
>
interface InboxInfo {
  title?: string
  description?: string
  icon?: Icon
  badge?: number
  subjectId?: HeapId
  url?: string
  updatedAt?: Date
  status?: StatusIcon
  data?: JSONObject | null
}
interface DbShardMoveState {
  status: 'PrimaryCopy' | 'Switch' | 'SecondaryCopy' | 'CleanSrcData'
  srcShardId: string
  dstShardId: string
  startTimestamp: number
}
declare type UgcFeed = Pick<Feed, 'title' | 'hooks'> & {
  id: Feed['uid']
  pinnedMessageId: Feed['pinned_message_id']
  lastMessageId: Feed['last_message_id']
  createdAt: Feed['created_at']
  updatedAt: Feed['updated_at']
  inboxSubjectId: Feed['model_id']
  inboxUrl: Feed['url']
  inboxExtraData: Feed['inbox_extra_data']
}
declare type UgcHeapRegistryLocalTable =
  | Record<'tableName' | 'modulePath' | 'exportName', string>
  | {
      tableName: string
      modulePath: string
      exportName: string
    }
declare type UgcPluginAppVmInfo = Pick<UgcCtxPluginApp, 'appId' | 'appSlug' | 'directoryPath'> & {
  /** @deprecated use codeAccount.id */
  hostAccId: number
  /** @deprecated use codeAccount.name */
  hostAccName: string
  codeAccount: UgcCtxAccount
}
declare class StorageFile extends sf.StorageFile implements sf.IStorageFile {
  protected readonly fileServiceHost: string
}
declare class StorageImageFile extends sf.StorageImageFile implements sf.IStorageImageFile {
  protected readonly fileServiceHost: string
}
declare class StorageVideoFile extends sf.StorageVideoFile implements sf.IStorageVideoFile {
  protected readonly fileServiceHost: string
  protected getVideoInfo(): Promise<VideoInfo>
}
declare class StorageAudioFile extends sf.StorageAudioFile implements sf.IStorageAudioFile {
  protected readonly fileServiceHost: string
}
declare class UgcRefLink<T extends object> extends BaseRefLink<T, RichUgcCtx> {
  protected prefetchValue: T | undefined
  /**
   * This method called by `prefetchFields` method. Allow to make batched prefetch values for
   * a bunch of reflink instances
   *
   * @param ctx
   * @param values
   */
  static prefetch(ctx: RichUgcCtx, values: Array<UgcRefLink<object>>): Promise<void>
  getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: RichUgcCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
  get<R = T>(ctx: RichUgcCtx): Promise<R>
}
declare class UgcGenericLink extends BaseGenericLink<RichUgcCtx> {
  getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: RichUgcCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
}
declare type UgcAnyHeapTableRepo<HSP extends hs.HsProperties> = UgcReadOnlyHeapTableRepo<HSP> | UgcHeapTableRepo<HSP>
declare class UgcReadOnlyHeapTableRepo<HSP extends hs.HsProperties> extends ReadOnlyHeapTableRepo<
  HSP,
  RichUgcCtx,
  RichUgcCtx
> {
  readonly tableName: string
  protected recordApi: UgcHeapTableRecordApi
  protected runtimeClasses: {
    RefLinkClass: typeof UgcRefLink
    GenericLinkClass: typeof UgcGenericLink
    FileClass: typeof StorageFile
    ImageFileClass: typeof StorageImageFile
    VideoFileClass: typeof StorageVideoFile
    AudioFileClass: typeof StorageAudioFile
  }
  constructor(
    tableName: string,
    type: string,
    fields: hs.HsPropertiesNo$<HSP>,
    recordApi: UgcHeapTableRecordApi,
    tableOptions?: HeapTableOptions<HSP>,
  )
  getSingleton(ctx: RichUgcCtx): Promise<this['T']>
}
declare class UgcHeapTableRepo<HSP extends hs.HsProperties> extends HeapTableRepo<HSP, RichUgcCtx, RichUgcCtx> {
  readonly tableName: string
  protected recordApi: UgcHeapTableRecordApi
  protected hostAccountId: number
  protected runtimeClasses: {
    RefLinkClass: typeof UgcRefLink
    GenericLinkClass: typeof UgcGenericLink
    FileClass: typeof StorageFile
    ImageFileClass: typeof StorageImageFile
    VideoFileClass: typeof StorageVideoFile
    AudioFileClass: typeof StorageAudioFile
  }
  /**
   * UGC table type always start with colon to easily prevent unauthorized access to core heap tables
   * @see constructUgcTableHeapTypeV2
   * :accountID suffix in type allows preventing naming conflicts when importing a heap table definition
   *  from another account
   */
  constructor(
    tableName: string,
    fields: hs.HsPropertiesNo$<HSP>,
    recordApi: UgcHeapTableRecordApi,
    hostAccountId: number,
    tableOptions?: HeapTableOptions<HSP>,
  )
  getSingleton(ctx: RichUgcCtx): Promise<this['T']>
  updateSingleton(ctx: RichUgcCtx, data: hs.HsCreateInputObject<HSP>): Promise<this['T']>
  resetSingleton(ctx: RichUgcCtx): Promise<this['T']>
}
declare type UgcHeapTableRecordApi = HeapTableRecordApi<RichUgcCtx, RichUgcCtx> & {
  pluginAppInfo?: UgcPluginAppVmInfo
  tableNsType: HeapTableNsType
}
declare type ZombieLinksCheckInfo = Array<[string, string[], number, string | undefined]>
declare type PerAccountKeyLangs = Record<number, Lang>
declare function registerLangBundle(lang: string, bundle: LangBundleKeys): void
declare type AccountUrlFn = {
  accountUrlParams: AccountUrlParams
  (path: string, options?: QueryParamsOption): string
}
interface AccountUrlParams {
  accountName: string
  accountHost: string
  accountPathPrefix: string
  pluginAppInfo?: UgcPluginAppUrlInfo
}
declare class UgcHttpResponseTuner {
  #private
  statusCode: number | undefined
  simplifiedContentType: SimplifiedContentType
  setHeader(name: string, value: string): this
  getHeader(name: string): string | undefined
  hasHeader(name: string): boolean
  removeHeader(name: string): this
  get headers(): Array<[string, string]> | undefined
  setCookie(name: string, value: string, options?: CookieOptions): this
  getCookie(name: string): CookieInfo | undefined
  hasCookie(name: string): boolean
  /**
   * Sends cookie header that tells the browser to delete cookie with this name and (optionally) path.
   * Don't mix up with removeCookie method below
   */
  clearCookie(name: string, options?: Omit<CookieOptions, 'expires' | 'maxAge'>): this
  /**
   * Remove cookie definition "command" previously defined during this request.
   * This method doesn't delete actually set cookie in browser!
   * Don't mix up with clearCookie which sends header that tells browser - delete this cookie.
   */
  removeCookie(name: string): this
  get cookies(): CookieInfo[] | undefined
  setStatusCode(code: number): this
  setSimplifiedContentType(type: SimplifiedContentType): this
  screen<T = unknown>(data: T): T
  json<T = unknown>(data: T): T
  html<T = unknown>(data: T): T
  plain<T = unknown>(data: T): T
  redirect(location: string, statusCode?: number): this
}
declare type SimplifiedContentType = 'screen' | 'json' | 'html' | 'plain' | 'unknown'
interface SerializedUgcHttpTuning {
  statusCode?: number
  headers?: Array<[string, string]>
  cookies?: CookieInfo[]
}
interface CookieInfo extends CookieOptions {
  name: string
  value: string
}
interface CookieOptions {
  expires?: Date
  maxAge?: number
  path?: string
  sameSite?: boolean | 'lax' | 'strict' | 'none'
}
declare type UgcHttpResponse = {
  http?: SerializedUgcHttpTuning
}
declare type UgcResponse =
  | (ScreenSuccessResponseV2 & UgcHttpResponse)
  | (ApiCallSuccessResponse & UgcHttpResponse)
  | (TuneHttpHeadersResponse & UgcHttpResponse)
  | unknown
  | ScreenErrorResponseV2
  | ApiCallErrorResponse
  | UgcErrorResponse
interface UgcErrorResponse {
  success: false
  errorType?: string
  statusCode: number
  reason?: string
  __type__?: 'getScreen' | 'apiCall' | 'getHtml'
  [key: string]: unknown
}
declare type UgcRouter = Map<UgcRequestMethod, UgcRouterData>
interface UgcRouterData {
  uniquePatterns: Set<string>
  exactRoutes?: Map<string, RouteHandlerFn>
  paramRoutes?: RegexRoute[]
  wildcardRoutes?: RegexRoute[]
}
interface RegexRoute {
  regex: RegExp
  names: string[]
  handler: RouteHandlerFn
}
declare type RouteHandlerFn = (ctx: RichUgcCtx, req: UgcRouteParsedRequest) => Promise<UgcResponse>
declare class CtxConsole {
  private logFn?
  constructor(
    logFn?:
      | import('isolated-vm').Reference<
          (level: 'error' | 'debug' | 'log' | 'warn' | 'info', ...args: unknown[]) => void
        >
      | undefined,
  )
  debug(...args: unknown[]): void
  log(...args: unknown[]): void
  info(...args: unknown[]): void
  warn(...args: unknown[]): void
  error(...args: unknown[]): void
  private writeLog
}
declare type ReqQuery = Record<string, string | string[] | undefined>
declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'unknown'
declare type UgcKvOpts = {
  [key: string]: string | number | undefined
}
interface UgcSerializedError {
  type: string
  message: string
  stack: string
}
interface UgcSerializedCtx {
  userId: string
  req: {
    method: string
    path: string
    query: string
    host: string
  }
  env: {
    platform: string
    version: number
    client?: ClientInfo
    clientScope?: string
    desktopLayout?: string
  }
  traceId: string
}
interface UgcSerilizedLog {
  msg: string
  ctx?: UgcSerializedCtx
  error?: UgcSerializedError
  kv?: UgcKvOpts
  json?: string
}
declare type LogParams = {
  err?: Error
  kv?: UgcKvOpts
  json?: unknown
  level?: LogLevel
  msg?: string | number
}
declare type LogParamsNoMsg = Omit<LogParams, 'msg'>
declare class RichUgcAccount implements Omit<UgcCtxAccount, 'metaHash'> {
  private acc
  private richUgcCtx
  readonly id: number
  readonly name: string
  readonly host: string
  readonly pathPrefix: string
  readonly authType: AccountAuthType
  private readonly metaHash
  constructor(acc: UgcCtxAccount, richUgcCtx: RichUgcCtx)
  get externalHost(): string | null
  get publishedVersion(): string | null
  url: AccountUrlFn
  apiCall<P>(url: string, apiParams?: P, options?: Parameters<typeof apiCall>[2]): ApiCallAction<P>
  navigate(url: string, options?: Parameters<typeof navigate>[1]): ReturnType<typeof navigate>
  /** @deprecated use ctx.account.url(path) instead */
  externalUrl(path: string): string
  redirect(targetPath: string): never
  /**
   * Returns attachMedia action targeted to the proper chatium file-service url bound to the account
   */
  attachMedia(params: Omit<AttachMediaAction, 'type' | 'filePutUrl' | 'getPutUrl'>): AttachMediaAction
  toJSON(): UgcCtxAccount
  log(params: LogParams): void
  log(msg: string | number, params?: LogParamsNoMsg): void
  log(msg: string | number, err?: Error): void
  log(err: Error): void
}
declare class RichUgcCtxDef implements Omit<UgcCtx, 'account' | 'app' | 'auth1' | 'rc' | 'router' | 'user2' | 'user1'> {
  readonly account: RichUgcAccount
  readonly auth?: UgcCtxBaseAuth & {
    expiresAt?: Date
  }
  readonly authSession?: UgcAuthSession
  readonly app: {
    readonly account: {
      readonly id: number
      readonly host: string
      readonly name: string
      readonly apiCall: typeof apiCall
      readonly navigate: typeof navigate
      readonly owner: UgcCtxUser1 | null
      url(path: string): string
      externalUrl(path: string): string
    }
    readonly apiCall: typeof apiCall
    readonly navigate: typeof navigate
    readonly user: UgcCtxUser1 | null
    url(path: string): string
  }
  readonly env: UgcCtx['env']
  readonly location: UgcCtxLocation | undefined
  readonly rc: UgcCtxRc
  readonly router: Pick<DeprecatedCtxRouter, 'filePath' | 'urlPath'>
  readonly session: UgcCtx['session']
  readonly timeZone: UgcCtx['timeZone']
  readonly user?: UgcSmartUser
  readonly req: UgcRouteParsedRequest<any>
  readonly resp: UgcHttpResponseTuner
  readonly console: CtxConsole
  readonly traceId: string
  readonly routeType?: UgcCtxRouteType
  private _lang
  /** accountId -> bundles */
  private langBundles
  /**
   * List of langs, whose bundles are actually loaded in langBundles and are effective for the ctx.t calls.
   * This list is used to preserve consistent logic when transferring translation for the client-side (browser) code.
   */
  private __effectiveLangs__
  private __keyLangPerAccount__
  /**
   * Same as langBundles but may contain empty slots in bundle lists for each account.
   * Helps to match lang bundles with order of __effectiveLangs__.
   * @see RichUgcCtxHiddenLangFeatures
   * @see getUntranslatedI18nKeys
   */
  private rawLangBundles
  constructor(ctx: UgcCtx, ctxFns: CtxOutsideFns, req: UgcRouteRequest)
  constructor(ctx: UgcInternalCtx, ctxFns: CtxOutsideFns)
  log(...args: unknown[]): void
  /**
   * @deprecated use import { requireAnyUser, requireRealUser } from '@app/auth'
   */
  getOrCreateUser(): Promise<UgcCtxUser1>
  toJSON(): UgcInternalCtx
  t(key: string, args?: TranslateArgs): string
  t(key: string | undefined, args?: TranslateArgs): string | undefined
  t(key: string | null, args?: TranslateArgs): string | null
  t(key: TranslationKey, args?: DynamicTranslateArgs): string
  t(key: TranslationKey | undefined, args?: DynamicTranslateArgs): string | undefined
  t(key: TranslationKey | null, args?: DynamicTranslateArgs): string | null
  t(key: TranslationKey | string, args?: TranslateArgs): string
  t<T extends null | undefined>(key: null | undefined, args?: TranslateArgs): T
  get lang(): Lang
  /**
   * Optionaly changes the current request lang and loads corresponding lang bundles (translations),
   *  so all necessary translations are available synchronously for ctx.t function
   */
  updateAndLoadLang(lang?: Lang): Promise<Lang>
}
interface UgcOutAccount {
  host: string
  externalHost: string | null
}
interface UgcOutCtx {
  traceId: string
  userId?: HeapId
  env?: Env
  account?: UgcOutAccount
}
declare type UgcTraceCtx = Pick<UgcOutCtx, 'traceId'>
declare type UgcOutUserCtx = Pick<UgcOutCtx, 'traceId' | 'userId'>
declare type UgcOutEnvCtx = Required<Pick<UgcOutCtx, 'traceId' | 'env'>>
declare type UgcOutAccountCtx = Required<Pick<UgcOutCtx, 'traceId' | 'account'>>
declare const HeapSingletonCache: unique symbol
interface RichUgcCtxWithInternalsDef extends RichUgcCtxDef {
  codeVersion?: UgcCodeVersion
  __ugc_internals__: {
    router: UgcRouter
    loadedClosureProxies: Map<string, Record<string | symbol, unknown>>
    loadedClosureModules: Map<string, Record<string | symbol, unknown>>
    loadingClosureModules: Map<string, UgcModuleSpecifier>
    txn?: [string, UgcHeapTransactionType]
    hooksByKey: Map<string, unknown>
  }
  [HeapSingletonCache]?: Record<string, unknown>
}
declare type RichUgcCtxWithInternals = RichUgcCtxWithInternalsDef
declare type UgcHeapTransactionType = 'batch' | 'serializable'
declare type DeprecatedCtxRouter = UgcCtx['router'] & {
  params: Record<string, unknown>
  readonly apiCall: typeof apiCall
  readonly navigate: typeof navigate
  setParam(key: string, val: unknown): Promise<void>
  url(path: string): string
  redirect(path: string): never
}
declare type UgcCtxRouteType = 'screen' | 'apiCall' | 'get' | 'post' | 'html' | 'job'
interface UgcCodeVersionInfo {
  codeAccountId: number
  loadFrom: UgcFileStorage
  version: CgsRepoVersion | null
}
declare type User2 = HeapObjectBaseV2 & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
interface ChatiumRc {
  defaultDesktopLayout?: DesktopLayout
  favicon?: string
  faviconHash?: string
  fonts?: ScreenPropsV2['fonts']
  htmlTemplate?: string
  ogDescription?: string
  ogImage?: string
  ogImageHash?: string
  ogTitle?: string
  ogType?: string
  title?: string
  titleScreen?: string
  headExtra?: string[]
  bodyExtra?: string[]
  layout?: Layout | string
  i18n?: {
    /**
     * Language, in which the in-code key strings are defined.
     * It's important to only set this if the keys are really of that language, not technical IDs
     *  because this info is used for proper language bundle loading.
     */
    keyLang?: Lang | null
    /**
     * List of languages to which auto-translation actions will target when they are activated
     */
    autoTranslateLangs?: Lang[]
    /**
     * List of languages that are considered supported in this account.
     * 'auto-detect-all' (default) - collect a combined set of translation languages from the account code,
     *                               external dependencies, and all connected plugin apps.
     * 'auto-detect-local-with-externals' - collect a combined set of translation languages only from the account code
     *                                      and external dependencies, without plugin apps
     * 'auto-detect-only-local' - collect a combined set of translation languages only from the account's own code
     *
     * Alternatively, an explicit list of languages may be provided which disable auto-detection.
     * @see getSupportedTranslationLangs
     */
    supportedLangs?: typeof i18nSupportedLangsAutoValues[number] | Lang[]
  }
  signInPath?: string
  globalJsx?: 'app/ui' | false
}
declare const i18nSupportedLangsAutoValues: readonly [
  'auto-detect-all',
  'auto-detect-local-with-externals',
  'auto-detect-only-local',
]
interface Layout {
  leftMenu?: {
    items?: LayoutMenuItem
  }
  bottomTabs?: LayoutBottomTabs
}
interface LayoutBottomTabs {
  tabs?: LayoutMenuItem[]
  activeTintColor?: string
  inactiveTintColor?: string
}
interface LayoutMenuItem {
  id?: string
  type: 'tab' | 'button'
  title?: string
  url?: string
  onClick?: ChatiumActions
  icon: IconProps
  key?: string
}
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface EnvCtx {
  env: Env
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type AuthSession = PublicFieldsOfClass<AuthSessionHelperClass>
declare class AuthSessionHelperClass {
  id: string
  account_id: number
  user_id: string
  auth_log: AuthLogItem[]
  device_name: string
  is_mobile: boolean
  os_name: string
  last_ip: string
  last_active_approx_at: Date
  created_at: Date
  /**
   * matching session token from the external auth provider or device ID for the anonymous user sessions
   * helps to avoid creating a new session duing upstream provider session revalidation
   * @see getOrCreateExternalAuthSession
   */
  external_token: string | null
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    auth_log: AuthLogItem[],
    device_name: string,
    is_mobile: boolean,
    os_name: string,
    last_ip: string,
    last_active_approx_at: Date,
    created_at: Date,
    /**
     * matching session token from the external auth provider or device ID for the anonymous user sessions
     * helps to avoid creating a new session duing upstream provider session revalidation
     * @see getOrCreateExternalAuthSession
     */
    external_token: string | null,
  )
}
interface AuthLogItem {
  provider: AuthProvider
  /**
   * Provider-specific additional data provided by the provider that can be used for later system call to the provider.
   */
  providerData?: AnyObject
  /**
   * 'AuthSession' means that this session has been authenticated by another active session with the session ID as a key
   */
  type: IdentityType | 'AuthSession'
  key: string
  authAt: number
}
declare class AccountHelperClass {
  id: number
  meta_hash: string
  name: string
  title: string
  domain: string | null
  is_domain_ready: boolean
  owner_id: number
  owners: HeapId[]
  logo: Icon | null
  created_at: Date
  lang: Lang | null
  auth_type: AccountAuthType
  type: AccountType
  external_id: string | null
  external_host: string | null
  expires_at: Date | null
  applications: number[]
  start_app: string | null
  published_version: CgsRepoVersion | null
  main_mobile_app_id: number | null
  parent_account_id: number
  path_prefix: string
  /**
   * if not empty, this is not a separate account, but code version container (brunch) for the given account ID
   */
  branch_of_account_id: number | null
  constructor(
    id: number,
    meta_hash: string, // hash of account meta information for synchronization invalidation
    name: string, // <name>.chatium.com
    title: string, // human-readable
    domain: string | null,
    is_domain_ready: boolean, // use custom domain name or use <name>.chatium.com
    owner_id: number, // auth ID
    owners: HeapId[], // user-v2 IDs
    logo: Icon | null,
    created_at: Date,
    lang: Lang | null,
    auth_type: AccountAuthType,
    type: AccountType,
    external_id: string | null,
    external_host: string | null,
    expires_at: Date | null,
    applications: number[],
    start_app: string | null,
    published_version: CgsRepoVersion | null,
    main_mobile_app_id: number | null,
    parent_account_id: number,
    path_prefix: string, //usefull for url buiding, e.g. https://<domain_name>/<path_prefix>
    /**
     * if not empty, this is not a separate account, but code version container (brunch) for the given account ID
     */
    branch_of_account_id: number | null,
  )
}
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare type Account = PublicFieldsOfClass<AccountHelperClass>
declare enum AccountType {
  Chatium = 'Chatium',
  Getcourse = 'Getcourse',
  FollowersClub = 'FollowersClub',
  Playground = 'Playground',
  Reserved = 'Reserved',
}
declare type UgcCodeVersion = CgsRepoVersion
interface UgcRouteRequest<Body = any> {
  method: UgcRequestMethod
  path: string
  query?: ReqQuery
  headers?: Record<string, string | undefined>
  body?: Body
}
interface UgcRouteParsedRequest<Body = any> extends UgcRouteRequest<Body> {
  params: Record<string, string>
  query: ReqQuery
  /** like in node, without protocol and domain, starting with slash, normalized, includes query params */
  url: string
}
declare type UgcRequestMethod = 'get' | 'post' | 'job'
declare type UgcCtxBaseAuth = Pick<Auth, 'id' | 'type' | 'key'>
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
declare type UgcAuthSession = Pick<AuthSession, 'id' | 'auth_log'> & {
  deviceName: string
}
declare type UgcCtxLocation = Location
interface UgcCtx extends UgcInternalCtx {
  router: {
    id: EntityId
    parentId: EntityId | null
    filePath: string
    name: string
    urlPath: string
    params?: Record<string, unknown> | null
  }
}
interface UgcInternalCtx extends EnvCtx, LangCtx {
  account: UgcCtxAccount
  app?: UgcCtxApp
  authSession?: UgcAuthSession
  user2?: UgcCtxUser2 | SerializedSmartUser
  location: UgcCtxLocation | undefined
  rc?: UgcCtxRc
  session: UgcCtxSession | null
  timeZone: string
  traceId: string
  auth1?:
    | (UgcCtxBaseAuth & {
        expiresAtMs?: number
      })
    | undefined
  user1?: UgcCtxUser1
}
declare type UgcCtxApp = UgcCtxProxyApp | UgcCtxPluginApp
interface UgcCtxPluginApp extends UgcPluginAppUrlInfo {
  type: 'UgcPlugin'
  appId: number
  callingAcc: UgcCtxAccount
  hostAccUser1?: UgcCtxUser1
  hostAccUser2?: UgcCtxUser2 | SerializedSmartUser
}
interface UgcPluginAppUrlInfo {
  appSlug: string
  /** path to the application root directory */
  directoryPath: string
}
interface UgcCtxProxyApp {
  type: 'UgcProxy'
  accId: number
  accName: string
  accHost: string
  accOwner: UgcCtxUser1 | null
  accUrl: string
  accExternalHost: string | null
  accPathPrefix: string | null
  appPrefix: string
  directoryPath: string | null
  user: UgcCtxUser1 | null
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
declare type UgcCtxRc = Pick<ChatiumRc, 'defaultDesktopLayout'>
interface UgcCtxSession {
  id: string
  email?: string
  phone?: string
}
declare type AnyObject = Record<string, unknown>
declare type FilterObject<T> =
  | FilterSingleObject<T>
  | TopAndOperator<T>
  | TopOrOperator<T>
  | TopNotOperator<T>
  | NoopOperator
declare type FilterSingleObject<T> = {
  [K in keyof T]?: FilterRighthand<T[K]>
}
declare type TopAndOperator<T> = {
  $and: Array<FilterObject<T>>
}
declare type TopOrOperator<T> = {
  $or: Array<FilterObject<T>>
}
declare type TopNotOperator<T> = {
  $not: FilterObject<T>
}
declare type FilterRighthand<V> =
  | null
  | V
  | Array<V>
  | Operator<V>
  | FilterSingleObject<V>
  | (V extends Date ? DateHint : never)
declare type Operator<V> =
  | GtOperator<V>
  | GteOperator<V>
  | LtOperator<V>
  | LteOperator<V>
  | HasOperator<V>
  | IncludesOperator<V>
  | NotOperator<V>
  | AndOperator<V>
  | OrOperator<V>
  | IlikeOperator<V>
  | NoopOperator
declare type GtOperator<V> = {
  $gt: V
}
declare type GteOperator<V> = {
  $gte: V
}
declare type LtOperator<V> = {
  $lt: V
}
declare type LteOperator<V> = {
  $lte: V
}
declare type IlikeOperator<V> = V extends string
  ? {
      $ilike: V
    }
  : never
declare type HasOperator<V> = {
  $has: V extends AnyObject ? keyof V : never
}
declare type IncludesOperator<V> = {
  $includes:
    | ArrayElement<V>
    | {
        $any: ArrayElement<V>[]
      }
    | {
        $all: ArrayElement<V>[]
      }
}
declare type NoopOperator = {
  $noop: unknown
}
declare type NotOperator<V> = {
  $not: FilterRighthand<V>
}
declare type AndOperator<V> = {
  $and: Array<FilterRighthand<V>>
}
declare type OrOperator<V> = {
  $or: Array<FilterRighthand<V>>
}
declare type DateHint = {
  $date: string
}
declare type ArrayElement<V> = V extends unknown[] ? V[number] : never
interface WithId {
  id: number | string
}
declare type Filter<T extends WithId> = FilterObject<T>
interface FindAllOptions<T extends WithId> {
  where?: Filter<T> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: OrderByDefinition<T> | null | undefined
}
declare type RequestDomainControlType = typeof validRequestDomainControlTypes[number]
declare const validRequestDomainControlTypes: readonly ['ZoneAndCert', 'OnlyCert', 'ProxiedCert', 'OnlyRoute']
declare class DomainHelperClass {
  id: number
  account_id: number
  name: string
  created_at: Date
  is_ready: boolean
  control_type: DomainControlType
  dns_records: DnsRecord[]
  lang: Lang | null
  path_prefix: string
  checked_at: Date
  constructor(
    id: number,
    account_id: number,
    name: string,
    created_at: Date,
    is_ready: boolean,
    control_type: DomainControlType,
    dns_records: DnsRecord[],
    lang: Lang | null,
    path_prefix: string,
    checked_at: Date,
  )
}
declare type DomainControlType = RequestDomainControlType | 'External'
declare type DnsRecordType = 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'NS' | 'MX' | 'PTR' | 'SRV' | 'CERT'
interface DnsRecord {
  id: string
  type: DnsRecordType
  name: string
  value: string
  ttl: number
}
declare type Domain = PublicFieldsOfClass<DomainHelperClass>
declare class CustomQueueJobHelperClass {
  account_id: number
  id: string
  app_id: number | null
  queue_name: string
  created_at: Date
  ugc_job_call_path: string
  ugc_job_payload: JSONObject
  priority: number | null
  constructor(
    account_id: number,
    id: string,
    app_id: number | null,
    queue_name: string,
    created_at: Date,
    ugc_job_call_path: string,
    ugc_job_payload: JSONObject,
    priority: number | null,
  )
}
declare type CustomQueueJob = Alias<PublicFieldsOfClass<CustomQueueJobHelperClass>>
declare type CustomQueueJobId = CustomQueueJob['id']
declare type CustomQueueJobScheduleParams = {
  priority?: number
}
declare type AccountAuthProvider = PublicFieldsOfClass<AccountAuthProviderHelperClass>
declare class AccountAuthProviderHelperClass {
  id: string
  account_id: number
  provider: AuthProvider
  enabled: boolean
  priority: number
  settings: AnyObject
  created_at: Date
  updated_at: Date
  constructor(
    id: string,
    account_id: number,
    provider: AuthProvider,
    enabled: boolean,
    priority: number,
    settings: AnyObject,
    created_at: Date,
    updated_at: Date,
  )
}
declare type SendEmailParams = {
  from: string
  to: string
  subject: string
  html: string
  text?: string
  cc?: string
  bcc?: string
  'amp-html'?: string
}
declare type SendEmailResult = {
  id: string
}
declare type GcClarityUid = string
interface GetcourseIcon {
  bgColor?: string
  color?: string
  image?: string
  text?: string
}
declare type GetcourseApiResponse<T = JSONObject> = GetcourseApiSuccessResponse<T> | GetcourseApiFailureResponse
interface GetcourseApiSuccessResponse<T> {
  success: true
  data: T
}
interface GetcourseApiFailureResponse {
  success: false
  message: string
}
declare type UgcGcSendMessageRequest = Omit<GcSendMessageRequest, 'accountId'>
declare type GcSendMessageRequest = {
  accountId: number
  mailingId: number
  objectId: number
  canResend: boolean
  sendNow: boolean
}
interface GetcourseAccountInfo {
  id: number
  name: string
  title: string
  domain: string
  logo: GetcourseIcon
  ownerEmail: string
  lang: Lang
}
declare type CreateParticipantOptions = Partial<Pick<Participant, 'role' | 'muted' | 'data' | 'hooks'>> & {
  silent?: boolean
  inboxDisabled?: boolean
}
declare type FeedMessagesAddHandlerResult = {
  success: true
  data: {
    added: ChatMessage
  }
}
interface Change {
  id: string
  prevId?: string
  operation: ChangeOperation
  messageId: string
  message?: ChatMessage
}
declare type ChangeOperation = 'create' | 'update' | 'delete'
interface IosIapReceipt {
  cancellation_date?: string
  cancellation_date_ms?: string
  cancellation_date_pst?: string
  cancellation_reason?: '0' | '1'
  expires_date?: string
  expires_date_ms?: string
  expires_date_pst?: string
  in_app_ownership_type?: 'FAMILY_SHARED' | 'PURCHASED'
  is_in_intro_offer_period: 'true' | 'false'
  is_trial_period: 'true' | 'false'
  is_upgraded?: 'true'
  offer_code_ref_name?: string
  original_purchase_date: string
  original_purchase_date_ms: string
  original_purchase_date_pst: string
  original_transaction_id: string
  product_id: string
  promotional_offer_id?: string
  purchase_date: string
  purchase_date_ms: string
  purchase_date_pst: string
  quantity: '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10'
  subscription_group_identifier: string
  transaction_id: string
  web_order_line_item_id: string
}
interface AndroidVerifyResult {
  isSuccessful: boolean
  errorMessage?: string
  /**
   * @see https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.products
   * @see https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.subscriptions
   */
  payload?: {
    acknowledgementState: 0 | 1
    developerPayload?: string
    kind: string
    obfuscatedExternalAccountId?: string
    obfuscatedExternalProfileId?: string
    orderId: string
    priceAmountMicros: string
    priceCurrencyCode: string
    purchaseType?: 0 | 1 | 2
    autoRenewing?: boolean
    autoResumeTimeMillis?: string
    cancelSurveyResult?: {
      cancelSurveyReason: 0 | 1 | 2 | 3 | 4
      userInputCancelReason: string
    }
    cancelReason?: 0 | 1 | 2 | 3
    countryCode?: string
    expiryTimeMillis?: string
    externalAccountId?: string
    introductoryPriceInfo?: {
      introductoryPriceCurrencyCode: string
      introductoryPriceAmountMicros: string
      introductoryPricePeriod: string
      introductoryPriceCycles: number
    }
    linkedPurchaseToken?: string
    paymentState?: 0 | 1 | 2 | 3
    priceChange?: {
      newPrice: {
        priceMicros: string
        currency: string
      }
      state: 0 | 1
    }
    profileName?: string
    emailAddress?: string
    givenName?: string
    familyName?: string
    profileId?: string
    promotionCode?: string
    promotionType?: 0 | 1
    startTimeMillis?: string
    userCancellationTimeMillis?: string
    consumptionState?: 0 | 1
    productId?: string
    purchaseState?: 0 | 1 | 2
    purchaseTimeMillis?: string
    purchaseToken?: string
    quantity?: number
    regionCode?: string
  }
}
declare class IapPurchaseHelperClass {
  id: number
  account_id: number
  user_id: HeapId | null
  session_id: string | null
  email_auth_id: number | null
  phone_auth_id: number | null
  session_auth_id: number | null
  original_transaction_id: string
  transaction_id: string | null
  created_at: Date
  updated_at: Date
  product_id: string
  purchased_at: Date
  expire_at: Date | null
  environment: IosTransactionEnvironment | null
  platform: 'iOS' | 'Android' | 'unknown'
  raw_info: IosIapReceipt | AndroidVerifyResult | null
  latest_update_type: IapUpdateType
  previous_user_id: HeapId | null
  constructor(
    id: number,
    account_id: number,
    user_id: HeapId | null,
    session_id: string | null,
    email_auth_id: number | null,
    phone_auth_id: number | null,
    session_auth_id: number | null,
    original_transaction_id: string,
    transaction_id: string | null,
    created_at: Date,
    updated_at: Date,
    product_id: string,
    purchased_at: Date,
    expire_at: Date | null,
    environment: IosTransactionEnvironment | null,
    platform: 'iOS' | 'Android' | 'unknown',
    raw_info: IosIapReceipt | AndroidVerifyResult | null,
    latest_update_type: IapUpdateType,
    previous_user_id: HeapId | null,
  )
}
declare type IapPurchase = PublicFieldsOfClass<IapPurchaseHelperClass>
declare type IapUpdateType = 'Purchased' | 'Renewed' | 'Refund' | 'OwnershipChanged' | 'Unknown'
declare enum IosTransactionEnvironment {
  Sandbox = 'Sandbox',
  Production = 'Production',
}
declare class InboxHelperClass {
  id: number
  auth_id: number
  account_id: number
  title: string
  description: string | null
  icon: Icon | null
  status: StatusIcon | null
  badge: number
  subject_id: string | null
  url: string
  updated_at: Date
  archived_at: Date | null
  pinned_at: Date | null
  data: JSONObject | null
  constructor(
    id: number,
    auth_id: number,
    account_id: number,
    title: string,
    description: string | null,
    icon: Icon | null,
    status: StatusIcon | null,
    badge: number,
    subject_id: string | null,
    url: string,
    updated_at: Date,
    archived_at: Date | null,
    pinned_at: Date | null,
    data: JSONObject | null,
  )
}
declare type Inbox = PublicFieldsOfClass<InboxHelperClass>
declare type UgcInbox = Pick<Inbox, 'title' | 'description' | 'badge' | 'url' | 'data'> & {
  icon: UgcInboxIcon | null
  subjectId: Inbox['subject_id']
  updatedAt: Inbox['updated_at']
  archivedAt: Inbox['archived_at']
  pinnedAt: Inbox['pinned_at']
}
interface UgcInboxIcon {
  name?: PlainIconName
  url?: string
  text?: string | number
  color?: string
  bgColor?: string
}
export interface UgcInboxData {
  items: Array<UgcInboxOld>
  socketIds: Array<string>
}
export interface UgcInboxOld {
  id: number | string
  auth_id: number
  account_id: number
  title: string
  description: string | null
  icon: UgcInboxIcon | null
  status: UgcInboxIcon | null
  badge: number
  subject_id: string | null
  url: string
  updated_at: Date
  archived_at: Date | null
  pinned_at: Date | null
  data: JSONObject | null
}
declare type ResetInboxBadgeParams =
  | {
      url: string
      subjectId?: string | null
    }
  | {
      url?: string | null
      subjectId: string
    }
interface MetricEventData {
  ts?: Date
  ts64?: number
  sign?: number
  title?: string
  account: Pick<Account, 'id' | 'type'>
  auth:
    | {
        id: string
      }
    | undefined
  user:
    | undefined
    | {
        id: string
        type: 'Anonymous' | 'Real' | 'Bot'
        firstName?: string | undefined
        lastName?: string | undefined
        accountRole?: string | undefined
        image?: string | undefined
        phone?: string | undefined
        email?: string | undefined
      }
  session:
    | undefined
    | {
        id: string | undefined
        phone?: string | undefined
        email?: string | undefined
      }
  uid: string | undefined
  sid: string | undefined
  inferredUid: boolean | undefined
  inferredSid: boolean | undefined
  gcVisitId: number | undefined
  gcVisitorId: number | undefined
  gcSessionId: number | undefined
  url: string
  hostname: string
  ip: string | undefined
  client?: {
    title: string | undefined
    referrer?: string | undefined
    userAgent?: string | undefined
    screenWidth?: number | undefined
    screenHeight?: number | undefined
    screenPixelRatio?: number | undefined
  }
  location?: {
    country?: string | undefined
    region?: string | undefined
    timeZone?: string | undefined
    city?: string | undefined
    latitude?: number | undefined
    longitude?: number | undefined
  }
  fcmToken?: string | undefined
  query?: {
    utm_funnel?: string | undefined
    utm_node?: string | undefined
    utm_node_from?: string | undefined
    utm_action?: string | undefined
    utm_action_params?: string | undefined
    utm_action_param1?: string | undefined
    utm_action_param2?: string | undefined
    utm_action_param3?: string | undefined
    utm_action_param1_float?: number | undefined
    utm_action_param2_float?: number | undefined
    utm_action_param3_float?: number | undefined
    utm_action_param4_float?: number | undefined
    utm_action_param1_int?: number | undefined
    utm_action_param2_int?: number | undefined
    utm_action_param3_int?: number | undefined
  }
  funnel?: string | undefined
  funnel_node?: string | undefined
  funnel_node_from?: string | undefined
  action?: string | undefined
  action_params?: string | undefined
  action_param1?: string | undefined
  action_param2?: string | undefined
  action_param3?: string | undefined
  action_param1_float?: number | undefined
  action_param2_float?: number | undefined
  action_param3_float?: number | undefined
  action_param4_float?: number | undefined
  action_param1_int?: number | undefined
  action_param2_int?: number | undefined
  action_param3_int?: number | undefined
  action_param1_arrstr?: string[] | undefined
  action_param2_arrstr?: string[] | undefined
  action_param3_arrstr?: string[] | undefined
  action_param1_uint32arr?: number[] | undefined
  utm_source?: string | undefined
  utm_medium?: string | undefined
  utm_content?: string | undefined
  utm_campaign?: string | undefined
  utm_term?: string | undefined
  keys?: string[]
  values?: string[]
  clrt_type?: string
  clrt_campaign_id?: string
  clrt_ad_id?: string
}
declare type DesktopBuiltinMapping = Record</* builtin name */ string, /* builtin name with hash */ string>
declare type CreateBotUserInfo = Pick<ExtendedUserFields, typeof botUserExtendedFields[number]>
declare const botUserExtendedFields: readonly ['firstName', 'middleName', 'lastName', 'imageHash', 'imageUrl']
interface ClickHouseConf {
  proto: 'https:' | 'http:'
  host: string
  port: number
  user?: string
  password?: string
  headers?: OutgoingHttpHeaders
  queryOptions?: Record<string, string | number | boolean>
  ca?: string
}
declare type QueryClickHouseOptions = {
  format?: 'JSON' | 'JSONCompact' | 'JSONEachRow' | 'JSONCompactEachRow' | 'CSV' | 'TabSeparated'
  batchSize?: number
  clickHouseCluster?: string
  clickHouseSettings?: any
  clickHouseServer?: ClickHouseConf
}
interface ChatiumHttpRequestOptions {
  url: string
  method?: Method
  body?: string
  json?: Record<string, unknown> | unknown[]
  form?: Record<string, unknown>
  headers?: Record<string, string | string[] | undefined>
  searchParams?: string | Record<string, string | number | boolean | null | undefined>
  responseType?: 'json' | 'text'
  resolveBodyOnly?: boolean
  username?: string
  password?: string
  throwHttpErrors?: boolean
}
interface ChatiumHttpResponse<T = unknown> {
  body: T
  statusCode: number
  headers: IncomingHttpHeaders
}
declare type Method =
  | 'GET'
  | 'POST'
  | 'PUT'
  | 'PATCH'
  | 'HEAD'
  | 'DELETE'
  | 'OPTIONS'
  | 'TRACE'
  | 'get'
  | 'post'
  | 'put'
  | 'patch'
  | 'head'
  | 'delete'
  | 'options'
  | 'trace'
declare class Transaction {
  readonly transactionId: string
  constructor(transactionId: string)
}
interface UgcHeapRepo<HD extends HeapData> {
  getMeta(): AnyObject
  getById(id: HeapId): Promise<HeapObject<HD>>
  findById(id: HeapId): Promise<HeapObject<HD> | null>
  findByIds(ids: HeapId[]): Promise<HeapObject<HD>[]>
  findAll(options?: HeapFindAllOptions<HD>): Promise<HeapObject<HD>[]>
  countBy(filter: HeapQueryFilter<HD>): Promise<number>
  findBy(filter: HeapQueryFilter<HD>): Promise<HeapObject<HD>[]>
  findOneBy(filter: HeapQueryFilter<HD>): Promise<HeapObject<HD> | null>
  create(
    data: Partial<UpdateFields<HD>> & {
      id?: HeapId
    },
  ): Promise<HeapObject<HD>>
  createOrUpdateBy<K extends HeapFieldName<HD>>(
    uniqKey: K,
    data: UpdateFields<HD> & Pick<HD, K>,
  ): Promise<HeapObject<HD>>
  update(patch: Partial<UpdateFields<HD>> & Pick<HeapObjectBase, 'id'>): Promise<HeapObject<HD>>
  updateMaybe(patch: Partial<UpdateFields<HD>> & Pick<HeapObjectBase, 'id'>): Promise<HeapObject<HD> | null>
  delete(id: HeapId): Promise<HeapObject<HD> | null>
  withTransaction(transaction: Transaction): UgcHeapRepoWithTransaction<HD>
}
declare type UgcHeapRepoWithTransaction<HD extends HeapData> = Omit<UgcHeapRepo<HD>, 'withTransaction'>
/**
 * External function proxies that are injected into chatium ugc VM runtime API during VM context initialization
 */
export interface UgcInternals {
  builtinModules: Map<string, any>
  closureModules: Map<string, RegisteredClosureModule>
  closureProxyModules: Map<string, RegisteredClosureModule>
  currentRouting: string | RichUgcCtxWithInternals | null
  currentRouterUrlPath: string | null
  currentCodeVersion: UgcCodeVersion | null
  resolvedModules: Map<string, any>
  proxyModules: Map<string, any>
  commonJSExports: Map<string, any>
  /**
   * Info injected by runtime to help heap table init code to properly register itself
   *  in the global heapTableRepoRegistry
   * @see UgcVm.loadModule
   * @see Heap.Table
   */
  curHeapModuleHash: string | null
  in: OutsideToVmApi
  out: VmToOutsideApi
  helpers: {
    /** @see injectInternalHelpersIntoVm */
    accountUrlConstructor: (account: UgcCtxAccount) => AccountUrlFn
    /**
     * Info about plugin app if this UgcVm is a plugin-app running isolate.
     * Used in different internal functions, including:
     *  - constructing correct target heap-type for RefLink fields
     *  - constructing correct URLs by RouteRefs
     *  - detecting correct code host account when loading heap table definitions
     * @see injectInternalHelpersIntoVm
     */
    readonly pluginAppInfo?: UgcPluginAppVmInfo
    /**
     * Used as stub argument for closure modules with heap tables initialization call
     * @see tsCtxClosureTransformer
     */
    fakeCtx: RichUgcCtx
    /**
     * Global registry of loaded heap table repos
     */
    heapTableRepoRegistry: {
      /**
       * Table repos are cached by the module hashes (and not CGS versions) because otherwise invalidation bugs occur
       *  when a new CGS version is published
       * @see registerHeapTable
       * @see obtainUgcHeapTableRepoByName
       */
      tablesByKey: Map<string, UgcAnyHeapTableRepo<hs.HsProperties>>
      /**
       * Caches - which heap-table module hash corresponds to the given CGS version.
       * That hash is then used to get right repo from `tablesByKey` above.
       * This two-step keying allows to properly invalidate caches when a new CGS version is published
       *  while old version had a module with unchanged hash but registered
       *  under wrong key (if it would be based on CGS version directly).
       *
       * Promise means that the value is currently requested from UgcVm and will be replaced with non-promise version
       * @see obtainUgcHeapTableRepoByName
       */
      hashesByCgsVersion: Map<string, string | Promise<string | null>>
      /**
       * This map is used for GC when module is unloaded
       * @see registerHeapTable
       * @see obtainUgcHeapTableRepoByName
       * @see disposeSingleModule
       */
      keysByModuleHash: Map<string, [string[], string[]]>
    }
    /**
     * Global registry of loaded hooks
     */
    hookRegistry: {
      /**
       * Hooks are cached by the module hashes (and not CGS versions) because otherwise invalidation bugs occur
       *  when a new CGS version is published
       * This structure limits only single handler for a hook per module.
       *  The limitation may be removed if necessary, but probably invalidation may become more complicated.
       * @see registerUgcHook
       * @see obtainUgcHookByName
       */
      hooksByKey: Map<string, unknown>
      /**
       * Caches - which hook modules hashes corresponds to the given CGS version.
       * Most hooks may have several defined handlers across multiple modules.
       * That hash is then used to get right hook from `hooksByKey` above.
       * This two-step keying allows to properly invalidate caches when a new CGS version is published
       *  while old version had a module with unchanged hash but registered
       *  under wrong key (if it would be based on CGS version directly).
       *
       * Promise means that the value is currently requested from UgcVm and will be replaced with non-promise version
       * @see obtainUgcHookByName
       */
      hashesByCgsVersion: Map<string, string[] | Promise<string[] | null>>
      /**
       * This map is used for GC when module is unloaded
       * @see registerUgcHook
       * @see obtainUgcHookByName
       * @see disposeSingleModule
       */
      keysByModuleHash: Map<string, [string[], string[]]>
    }
    /**
     * Global registry of loaded i18n lang bundles
     */
    langRegistry: {
      /**
       * Lang-bundles are cached by the module hashes (and not CGS versions) because otherwise invalidation bugs occur
       *  when a new CGS version is published
       * @see registerLangBundle
       * @see ensureUgcLangBundlesLoaded
       */
      bundlesByModuleHash: Map<string, LangBundle>
      /**
       * Caches - which lang bundle module hashes correspond to the given CGS version.
       * For every lang scecifier there may be several bundles loaded, including fallback language bundles.
       * Resulting hashes are then used to get right bundles from `bundlesByModuleHash` above.
       * This two-step keying allows to properly invalidate caches when a new CGS version is published
       *  while the old version had a module with unchanged hash but registered
       *  under a wrong key (if it is based on CGS version directly).
       *
       * Promise means that the value is currently requested from UgcVm and will be replaced with non-promise version
       * @see obtainCgsLangBundles
       */
      hashesByCgsVersion: Map<
        /** CgsRepoVersion + ':' + reqCtxLangs separated by : */
        string,
        /** [Lang, [ModuleHash, accountId][]] */
        UgcLangBundlesLoadInfo | Promise<UgcLangBundlesLoadInfo>
      >
      /**
       * This map is used for GC when module is unloaded
       * @see obtainCgsLangBundles
       * @see disposeSingleModule
       */
      keysByModuleHash: Map<string, string[]>
    }
    /**
     * Does this isolate handle the development version (db) or published production version (cgs)
     * @see injectInternalHelpersIntoVm
     */
    vmModulesLoadFrom: UgcFileStorage | null
    registerLangBundle: typeof registerLangBundle
    /** @see HttpRouteRefClass.url */
    accountUrl: AccountUrlFn
    httpConfDomain: string
    enrichOutwardCallError(fnName: string, err?: Error): never
    registerHeapTable<HSP extends hs.HsProperties>(
      tableName: string,
      repo: UgcAnyHeapTableRepo<HSP>,
      heapModuleHash: NonNullable<UgcInternals['curHeapModuleHash']>,
    ): void
    ugcHeapRepoModule<HD extends HeapData>(
      ctx: RichUgcCtx,
      heapType: HeapObjectType,
      fields: HeapFieldMetas<HD>,
    ): UgcHeapRepo<HD>
    serializeConsoleArguments(...args: unknown[]): string[]
  }
  closureImport<T = Record<string, unknown>>(module: string | UgcModuleSpecifier, ctx: RichUgcCtx): T
  importModule(module: UgcModuleSpecifier): unknown
  getModuleMember(hash: string, memberName: string, path: string): unknown
  getClosureModuleMember(ctx: RichUgcCtx, hash: string, memberName: string, path: string): unknown
  debug(...args: unknown[]): void
  debugAsyncCtx(expectedCtx: RichUgcCtx, msg?: string): void
}
export declare type RegisteredClosureModule = [ClosureModule, string, UgcCodeVersion]
export interface UgcModuleSpecifier {
  hash: string
  origin: string
  specifier: string
  path: string
}
export interface OutsideToVmApi {
  handleInternalRequest: HandleInternalRequestFn<any>
  handleRequest(
    moduleHash: string,
    ctx: UgcCtx,
    req: UgcRouteRequest,
    codeVersion: UgcCodeVersion | undefined,
    ctxFns: CtxOutsideFns,
    timeoutMs: number,
    timeoutId: number,
  ): Promise<string | void>
  disposeModuleRefs(moduleHash: string | string[]): void
  /**
   * Tables' meta information is inside the isolate
   *  while link-integrity checking is performed outside during DB interaction.
   */
  hasNonZombieRestrictHeapLinks(
    loadFrom: UgcFileStorage,
    version: CgsRepoVersion | null,
    linkFieldsToCheck: ZombieLinksCheckInfo,
    deletingRecordType: HeapObjectType,
  ): Promise<boolean>
  registerModuleExports(
    moduleType: 'proxyModules' | 'resolvedModules',
    moduleHash: string,
    exports: Reference,
  ): Promise<void>
  evaluateRootModule(
    hash: string,
    codeAccountId: number,
    loadFrom: UgcFileStorage,
    version: CgsRepoVersion | HeapId,
    filePath: string,
  ): Module
}
export declare type HandleInternalRequestFn<Req extends UgcInternalRequestPayload> = (
  ctx: UgcInternalCtx,
  ctxFns: CtxOutsideFns,
  codeVersion: UgcCodeVersion | undefined,
  req: Req,
  timeoutMs: number,
  timeoutId: number,
) => Promise<
  | {
      success: true
      result: string
    }
  | {
      success: false
      reason: string
    }
  | void
>
export interface CtxOutsideFns {
  log?: Reference<(level: 'debug' | 'log' | 'info' | 'warn' | 'error', ...args: unknown[]) => void>
}
export interface VmToOutsideApi {
  authService: UgcAuthServiceApi
  jobsService: UgcJobsServiceApi
  syncService: UgcSyncServiceApi
  feedService: UgcFeedServiceApi
  fileService: UgcFileServiceApi
  i18nService: UgcI18nServiceApi
  iapService: UgcIapServiceApi
  usersService: UgcUserServiceApi
  accountService: UgcAccountServiceApi
  mobileApp: UgcMobileAppServiceApi
  heap: UgcHeapApi
  appSharedHeap?: UgcHeapApi
  heapV2: UgcHeapApiV2
  appHostHeapV2: UgcHeapApiV2
  entity: UgcEntityApi
  socketApi: UgcSocketApi
  inboxService: UgcInboxServiceApi
  appService: UgcAppServiceApi
  formStorage: UgcFormStorageApi
  htmlService: UgcHtmlServiceApi
  vm: UgcVmInternalApi
  logService: UgcLogServiceApi
  gcService: UgcGcServiceApi
  httpRequest: UgcHttpRequestFn
  isolatedEvalService: UgcIsolatedEvalServiceApi
  appMetricService: UgcAppMetricServiceApi
  /** @deprecated use __ugc_internals__.gcService.gcApiRequest instead */
  gcApiRequest<T = JSONObject>(path: string, payload: AnyObject): Promise<ChatiumHttpResponse<GetcourseApiResponse<T>>>
  timeoutPromise(timeoutMs: number): Promise<void>
  emailService: UgcEmailServiceApi
  ugcService: UgcUgcServiceApi
}
export declare type UgcHttpRequestFn = <T = unknown>(
  options: ChatiumHttpRequestOptions,
) => Promise<ChatiumHttpResponse<T>>
export interface UgcGcServiceApi {
  gcApiRequestWithCtx<T = JSONObject>(
    outCtx: UgcOutAccountCtx,
    path: string,
    payload: AnyObject,
    userIdOrEmail?: string | null,
  ): Promise<ChatiumHttpResponse<GetcourseApiResponse<T>>>
  resyncGcUser(outCtx: UgcOutUserCtx, gcUserId: number): Promise<void>
  sendMessage(outCtx: UgcOutUserCtx, messageRequest: UgcGcSendMessageRequest): Promise<void>
  getClarityUids(outCtx: UgcOutUserCtx, gcUserId: number): Promise<GcClarityUid[]>
}
export interface UgcLogServiceApi {
  log(msg: string, level?: LogLevel, kv?: UgcKvOpts): void
  logObj(obj: UgcSerilizedLog, level?: LogLevel): void
}
export interface UgcI18nServiceApi {
  getSupportedTranslationLangs(options?: GetSupportedTranslationLangsOptions): Promise<TranslationLangInfo | null>
}
export interface GetSupportedTranslationLangsOptions {
  forceWithoutExternals?: true
  forceWithoutApps?: true
}
export declare type TranslationLangInfo = Record<
  Lang,
  {
    lang: Lang
    /** does the account's own code have translations for this lang? */
    account: boolean
    /** Percentage of deep external dependencies which have tranlations for this lang, false if they weren't scanned */
    externals: false | number
    /** Percentage of installed plugin apps which have translations for this lang, false if they weren't scanned */
    apps: false | number
  }
>
export interface UgcIapServiceApi {
  findAllIapsByUserOrSession(userId?: HeapId, sessionId?: string): Promise<UgcIapPurchase[]>
  findIapsByOriginalTransactionIds(txnIds: string[]): Promise<UgcIapPurchase[]>
}
export interface UgcIapPurchase {
  productId: string
  purchasedAt: Date
  expireAt: Date | null
  sessionId: string
  userId: HeapId | null
  originalTransactionId: string
  lastTransactionId: string | null
  environment: IosTransactionEnvironment | null
  platform: IapPurchase['platform']
  rawInfo?: IosIapReceipt | AndroidVerifyResult
  lastUpdateType: IapUpdateType
  previousUserId: HeapId | null
}
export interface UgcVmInternalApi {
  /**
   * The function is optional because it's injected asynchronously during VM construction
   *  and may be undefined during first second after VM is started, but this is and shouldn't
   *  affect cache invalidation logic at all
   * @see UgcVm.construct
   */
  touchModuleCache(moduleHash: string): void
  /**
   * Loads the given tableName's module with the given CGS version into the VM
   *  so that the table registers itself in global registry
   *  and will be available for RefLink.get and other such functions
   * @returns hash of the module containing the table
   */
  loadHeapTableRepoByCgsVersionAndType(
    outCtx: UgcTraceCtx,
    codeVersion: CgsRepoVersion,
    tableName: string,
    accountToken: string | undefined,
    strict?: boolean,
    sourceAccountType?: HeapTableSourceAccountType,
  ): Promise<string | null>
  /**
   * Same as CGS-specific function above but for DB-version of code
   * @returns hash of the module containing the table
   */
  loadHeapTableRepoByDbBranchAndType(
    outCtx: UgcTraceCtx,
    codeVersion: undefined,
    tableName: string,
    strict?: boolean,
    sourceAccountType?: HeapTableSourceAccountType,
  ): Promise<string | null>
  /**
   * Loads the given hook's module with the given CGS version into the VM
   *  so that the hook registers itself in global registry
   *  and will be available for hook-dependent functionality
   * @returns hashes of the modules containing the hook handler definitions (app.hook)
   */
  loadHookByCgsVersionAndName(
    outCtx: UgcTraceCtx,
    codeVersion: CgsRepoVersion,
    hookName: string,
  ): Promise<string[] | null>
  /**
   * Same as CGS-specific function above but for DB-version of code
   * @returns hashes of the modules containing the hook handler definitions (app.hook)
   */
  loadHookByDbBranchAndName(outCtx: UgcTraceCtx, codeVersion: undefined, hookName: string): Promise<string[] | null>
  /**
   * Loads into the VM lang-bundle modules with the given CGS version
   *  corresponding the given langs collected from the request data and account rc settings
   *  so that the bundle registers itself in global registry and will be available for obtainCgsLangBundles
   * @returns hashes of the modules containing the lang bundles (paired with the corresponding lang)
   */
  loadBundlesByCgsVersionAndLang(
    outCtx: UgcTraceCtx,
    codeVersion: CgsRepoVersion,
    reqCtxLangs: Lang[],
  ): Promise<UgcLangBundlesLoadInfo>
  /**
   * Same as CGS-specific function above but for DB-version of code
   * @returns hashes of the modules containing the lang bundles (paired with the corresponding lang)
   */
  loadBundlesByDbBranchAndLang(
    outCtx: UgcTraceCtx,
    codeVersion: undefined,
    reqCtxLangs: Lang[],
    withoutExternals?: boolean,
  ): Promise<UgcLangBundlesLoadInfo>
}
/**
 * Points from which account the heap table code should be loaded:
 *  - `current` means the code of the currently running account
 *    (the data-owner account, the account on which domain the current request is running)
 *    even if the table is requested from the plugin application code (another account)
 *
 *  - `code` means the account whose code is currently running
 *    if it's a plugin app code, then the table will be loaded from the plugin app's account source
 */
export declare type HeapTableSourceAccountType = 'current' | 'code'
/** [ [Lang, [ModuleHash, accountId][]][], accountId -> keyLang ] */
export declare type UgcLangBundlesLoadInfo = [Array<readonly [Lang, Array<[string, number]>]>, PerAccountKeyLangs]
export interface UgcAuthServiceApi {
  createAnonymousUser(sessionId: SessionId, clientInfo: ClientInfo): Promise<[UgcCtxUser2, string]>
  createRealUser(
    reqCtx: {
      userId?: HeapId
    },
    userInfo: CreateRealUserInfo,
  ): Promise<UgcCtxUser2>
  createOrUpdateBotUser(
    reqCtx: {
      userId?: HeapId
    },
    username: string,
    userInfo?: CreateBotUserInfo,
  ): Promise<UgcCtxUser2>
  authenticateUserInChildAccount(
    childAccountId: number,
    parentUserId: HeapId,
    parentAuthSessionId: string,
    clientInfo: ClientInfo,
  ): Promise<string>
  createAuthSessionTokenByAnotherSession(
    reqCtx: {
      userId: HeapId
    },
    sourceSessionId: string,
    targetDomain: string,
  ): Promise<string>
  getPrimaryIdentitiesForUsers(userIds: HeapId[]): Promise<PrimaryIdentitiesByUser>
  findUserIdsByFuzzyIdentityKeys(types: IdentityType[], word: string): Promise<HeapId[]>
  findUserIdsByFuzzyCoreFields(word: string): Promise<HeapId[]>
  findUserIdsByCoreFields(options: FindCoreUsersOptions): Promise<HeapId[]>
  findCoreUsersByIds(allIds: HeapId[]): Promise<UgcCtxUser2[]>
  findCoreUserById(id: HeapId): Promise<UgcCtxUser2 | null>
  updateUserAccountRole(userId: HeapId, newRole: AccountRole, currentUserId?: HeapId): Promise<AccountRole>
  updateUserUsername(userId: HeapId, username: string, currentUserId?: HeapId): Promise<string>
  updateUserPassword(userId: HeapId, password: string, currentUserId?: HeapId): Promise<void>
  updateUserLang(userId: HeapId, lang: Lang | null, currentUserId?: HeapId): Promise<Lang | undefined>
  updateUserExtendedFields(userId: HeapId, fields: UpdateExtendedUserInfo, currentUserId?: HeapId): Promise<UgcCtxUser2>
  findIdentities(options: FindIdentitiesOptions): Promise<UgcIdentity[]>
  createUnconfirmedIdentity(
    reqCtx: {
      userId?: HeapId
    },
    params: CreateIdentityParams,
  ): Promise<UgcIdentity>
  makeIdentityPrimary(
    reqCtx: {
      userId?: HeapId
    },
    identityId: string,
  ): Promise<UgcIdentity>
  deleteIdentity(
    reqCtx: {
      userId?: HeapId
    },
    identityId: string,
  ): Promise<UgcIdentity | null>
  getSignInEnabledAuthProviders(): Promise<SignInEnabledAuthProviders>
  getAuthProvidersSettings(): Promise<UgcAuthProviderSettings[]>
  updateAuthProviderSettings(
    provider: AuthProvider,
    patch: {
      enabled?: boolean
      priority?: number
      settings?: AnyObject
    },
  ): Promise<UgcAuthProviderSettings>
  deleteAuthProviderSettings(provider: AuthProvider): Promise<void>
  createOrUpdateAuthSessionByConfirmedIdentity(
    requestCtx: AuthRequestCtx,
    identityType: CustomProvidableIdentityType,
    identityKey: string,
    provider: AuthProviderProps,
  ): Promise<CreateAuthSessionResult>
  createUserWithConfirmedIdentity(
    outCtx: UgcTraceCtx,
    identityType: CustomProvidableIdentityType,
    identityKey: string,
    provider: AuthProviderProps,
  ): Promise<CreateUserWithIdentityResult>
  acquireAuthSessionForDevice(authSessionId: string, deviceId: string): Promise<string>
  calcTgHash(ctx: UgcTraceCtx, botToken: string, checkString: string): Promise<string>
}
export declare type CreateUserWithIdentityResult = {
  userId: HeapId
  identityId: string
}
export declare type SignInEnabledAuthProviders = Record<
  AuthProvider,
  {
    priority: number
    settings: AnyObject
  }
>
export interface CreateIdentityParams {
  userId: HeapId
  type: 'Email' | 'Phone'
  key: Identity['key']
  isBlocked?: boolean
}
export declare type CreateRealUserInfo = ExtendedUserFields & CreateRealUserCoreInfo
export declare type CreateRealUserCoreInfo = {
  username?: string
  accountRole?: Exclude<AccountRole, 'Owner'>
  unconfirmedIdentities?: {
    Phone?: string
    Email?: string
  }
}
export interface FindCoreUsersOptions {
  where?: {
    type?: User2['type']
    accountRole?: AccountRole | AccountRole[]
    username?: string
  }
  limit?: number
}
export declare type FindIdentitiesOptions = FindAllOptions<UgcIdentity>
export interface UgcIdentity {
  id: Identity['id']
  userId: Identity['user_id']
  type: Identity['type']
  key: Identity['key']
  isPrimary: Identity['is_primary']
  isBlocked: Identity['is_blocked']
  confirmedBy: Identity['confirmed_by']
  createdAt: Identity['created_at']
  updatedAt: Identity['updated_at']
}
export declare type CreateAuthSessionResult =
  | (CreateAuthSessionResultCreated & {
      token: string
    })
  | CreateAuthSessionResultRedirect
export declare type CreateAuthSessionResultCreated = {
  type: 'created'
  authSessionId: string
  userId: HeapId
  identityId: string
}
export declare type CreateAuthSessionResultRedirect = {
  type: 'redirect'
  userId: string
  identityId: string
  redirect: {
    type: 'gcWeb'
    url: string
    token: string
  }
}
export interface AuthRequestCtx {
  authSessionId: string | undefined
  deviceId: string
  env: Env
  lang: string
  timeZone: string
}
export declare type UgcAuthProviderSettings = Pick<
  AccountAuthProvider,
  'provider' | 'enabled' | 'settings' | 'priority'
>
export interface UgcFileServiceApi {
  readonly fileServiceHost: string
  readonly fileServiceCdnHost: string
  getVideoInfo(ctx: LocationCtx, hash: string): Promise<VideoInfo>
}
export interface UgcMobileAppServiceApi {
  getMobileAppLink(url: string, options?: GetMobileAppLinkOptions): Promise<string>
  generateMobileAppRunActionUrlPath(appBundleId: string, action: Exclude<ChatiumAction, string>): Promise<string>
}
export interface UgcFeedServiceApi {
  getOrCreateEntityPersonalFeed(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    authOrUserId: number | HeapId,
    entityId: string,
  ): Promise<Feed>
  getChat(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    authOrUserId: number | HeapId,
    feedUid: string,
    appAccountId?: number,
  ): Promise<ChatProps>
  getOrCreateHeapObjectFeed(
    env: Env,
    heapObject: Pick<HeapObjectBase, 'id' | 'heapType'>,
    data?: Partial<Feed>,
  ): Promise<Feed>
  createOrUpdateHeapObjectFeed(
    env: Env,
    heapObject: Pick<HeapObjectBase, 'id' | 'heapType'>,
    data: Partial<Feed>,
  ): Promise<Feed>
  getOrCreateParticipantForFeed(
    authOrUserId: number | HeapId | null,
    env: Env,
    feedUid: string,
    userId: HeapId,
    options?: CreateParticipantOptions,
  ): Promise<UgcParticipant>
  findMessagesByExternalId(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    feedUid: string,
    externalId: string,
  ): Promise<Message[]>
  findMessagesByOriginIdType(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    feedUid: string,
    originId: string | null,
    originType: string | null,
  ): Promise<Message[]>
  createFeedMessage(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    authOrUserId: number | HeapId | null,
    feedUid: string,
    authorUserId: HeapId,
    data: MessageData,
    options?: CreateFeedMessageOptions,
  ): Promise<Message>
  updateFeedMessage(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    authOrUserId: number | HeapId | null,
    feedUid: string,
    messageId: string,
    message: Partial<Message>,
  ): Promise<Message>
  deleteFeedMessage(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    authOrUserId: number | HeapId | null,
    feedUid: string,
    messageId: string,
  ): Promise<void>
  findFeedMessageById(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    feedUid: string,
    id: string,
  ): Promise<Message | null>
  setFeedPinnedMessage(feedUid: string, messageId: string | null): Promise<void>
  createOrUpdateFeedParticipant(
    authOrUserId: number | HeapId | null,
    env: Env,
    feedId: string,
    userId: HeapId,
    options?: CreateParticipantOptions,
  ): Promise<UgcParticipant>
  deleteFeedParticipant(env: Env, feedId: string, participantId: HeapId): Promise<void>
  findFeedParticipants(env: Env, feedId: string, options?: FindAllOptions<UgcParticipant>): Promise<UgcParticipant[]>
  getFeedParticipantsCount(feedUid: string): Promise<number>
  feedMessagesGetHandler(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    userId: HeapId,
    feedUid: string,
    query: Record<string, string>,
    checkAccess?: boolean,
  ): Promise<FeedMessagesJson>
  feedMessagesChangesHandler(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    userId: HeapId,
    feedUid: string,
    query: Record<string, string>,
  ): Promise<FeedChangesJson>
  feedMessagesAddHandler(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    userId: HeapId,
    feedUid: string,
    body: any,
  ): Promise<FeedMessagesAddHandlerResult>
  feedParticipantsMarkAsReadHandler(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    userId: HeapId,
    feedUid: string,
    body: any,
  ): Promise<void>
  feedParticipantsLastReadHandler(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    userId: HeapId,
    feedUid: string,
  ): Promise<{
    success: true
    data: {
      lastReadAt: number
    }
  }>
  feedParticipantsLastRead(
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    userIdOrIds: HeapId | HeapId[],
    feedUid: string,
  ): Promise<number>
}
export declare type FeedChangesJson = {
  success: true
  changes: Change[]
}
export declare type FeedMessagesJson = {
  success: true
  data: {
    messages: ChatMessage[]
    lastChangeId?: string | undefined | null
  }
}
export interface CreateFeedMessageOptions {
  sendPush?: boolean
}
export declare type MessageData =
  | string
  | NormalMessageData
  | SystemMessageData
  | BlocksMessageData
  | HistoryMessageData
declare type NormalMessageData = {
  type?: 'Message'
  text: string
  files?: Message['files']
  data?: JSONObject
} & MessageDataCommon
declare type SystemMessageData = {
  type: 'System'
  text: string
  data?: JSONObject
} & MessageDataCommon
declare type BlocksMessageData = {
  type: 'Blocks'
  data: {
    blocks: unknown[]
  } & JSONObject
} & MessageDataCommon
declare type HistoryMessageData = {
  type: 'Change'
  data: ChangeMessageData
  text?: string | null
} & MessageDataCommon
declare type MessageDataCommon = Partial<
  Pick<Message, 'as_feed' | 'reply_to' | 'external_id' | 'origin_id' | 'origin_type'>
>
export interface UgcHeapApiV2 extends UgcHeapTransactionApi {
  findHeapRecordByTypeAndId(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    id: HeapId,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord | null>
  findHeapRecordsByTypeAndIds(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    ids: HeapId[],
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord[]>
  queryHeapRecords<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    options: HeapRecordSelectOptions<HSP> | undefined,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord[]>
  queryHeapRecordIds<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    options: HeapRecordSelectOptions<HSP> | undefined,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapId[]>
  countHeapRecords<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    filter?: HeapRecordFilter<HSP> | null,
    transactionId?: Transaction['transactionId'],
  ): Promise<number>
  createHeapRecord<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    linkInfo: HeapLinkInfo[],
    data: Static<hs.HsObject<T>> & {
      id?: HeapId
    },
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord>
  updateHeapRecordMaybe<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    linkInfo: HeapLinkInfo[],
    patch: Partial<Static<hs.HsObject<T>>> & {
      id: HeapId
    },
    optionalFieldsToClear?: Array<keyof T>,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord | null>
  createOrUpdateHeapRecordBy<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    linkInfo: HeapLinkInfo[],
    uniqKey: hs.HsProperty<T>,
    patch: Static<hs.HsObject<T>>,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord>
  deleteHeapRecord(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    id: HeapId,
    ugcInfo: UgcCodeVersionInfo,
    hardDelete: boolean,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord | null>
  createOrUpdateSingleton<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    createLinkInfo: HeapLinkInfo[],
    createData: Static<hs.HsObject<T>>,
    updateLinkInfo: HeapLinkInfo[],
    updatePatch: Partial<Static<hs.HsObject<T>>>,
    optionalFieldsToClear: Array<keyof T> | undefined,
    transactionId?: Transaction['transactionId'],
  ): Promise<HeapRecord>
  getFeedById(outCtx: UgcTraceCtx, feedId?: Feed['uid'], transactionId?: string): Promise<UgcFeed>
  createFeed(outCtx: UgcTraceCtx, feedProps?: UgcCreateFeedProps, transactionId?: string): Promise<UgcFeed>
  updateFeed(outCtx: UgcTraceCtx, feedProps: UgcUpdateFeedProps, transactionId?: string): Promise<UgcFeed>
  deleteFeed(
    outCtx: UgcTraceCtx,
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    feedId?: Feed['uid'],
    transactionId?: string,
  ): Promise<UgcFeed | null>
  getAccountCgsTablesInfo(outCtx: UgcTraceCtx, codeVersion: CgsRepoVersion): Promise<UgcHeapRegistryLocalTable[]>
  getAccountDbVersionTablesInfo(outCtx: UgcTraceCtx): Promise<UgcHeapRegistryLocalTable[]>
}
/**
 * How to convert plain `:<tableName>:<accId>` to heap type field for plugin applications:
 *  - `default` - add `app:<appId>` prefix for plugin app code calls
 *  - `account` - don't add app prefix - access data account-owned tables (only with relevant app permissions)
 *  - `core` - map given name using special hardcoded map to the core table type (currently, only users -> core.User)
 */
export declare type HeapTableNsType = 'default' | 'account' | 'core'
export declare type UgcCreateFeedProps = Partial<
  Pick<UgcFeed, 'title' | 'hooks' | 'inboxSubjectId' | 'inboxUrl' | 'inboxExtraData'>
>
export declare type UgcUpdateFeedProps = {
  id: UgcFeed['id']
} & UgcCreateFeedProps
export interface UgcHeapApi extends UgcHeapTransactionApi {
  findHeapRecordByTypeAndId(
    entityId: string,
    id: HeapId,
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord | null>
  findHeapRecordsByTypeAndIds(
    entityId: string,
    ids: HeapId[],
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord[]>
  findAllHeapRecordsByType(entityId: string, builtInHeapType?: string, transactionId?: string): Promise<HeapRecord[]>
  countHeapRecords<HD extends HeapData>(
    entityId: string,
    findAllOptions: {
      where?: HeapQueryFilter<HD> | null | undefined
    },
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<number>
  queryHeapRecords<HD extends HeapData>(
    entityId: string,
    fields: HeapFieldMetas<HD>,
    findAllOptions: HeapFindAllOptions<HD>,
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord[]>
  createHeapRecord<HD extends HeapData>(
    entityId: string,
    fields: HeapFieldMetas<HD>,
    data: Partial<UpdateFields<HD>> & {
      id?: HeapId
    },
    userId?: HeapId,
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord>
  createOrUpdateHeapRecordBy<HD extends HeapData & Record<string, unknown>, K extends HeapFieldName<HD>>(
    entityId: string,
    uniqKey: K,
    fields: HeapFieldMetas<HD>,
    data: Partial<UpdateFields<HD>> & Pick<HD, K>,
    userId?: HeapId,
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord>
  updateHeapRecordMaybe<HD extends HeapData>(
    entityId: string,
    fields: HeapFieldMetas<HD>,
    patch: Partial<UpdateFields<HD>> & Pick<HeapObjectBase, 'id'>,
    userId?: HeapId,
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord | null>
  deleteHeapRecord<HD extends HeapData>(
    entityId: string,
    fields: HeapFieldMetas<HD>,
    id: HeapId,
    userId?: HeapId,
    hard?: boolean,
    builtInHeapType?: string,
    transactionId?: string,
  ): Promise<HeapRecord | null>
}
export interface UgcHeapTransactionApi {
  beginTransaction(outCtx: UgcTraceCtx, txnType: UgcHeapTransactionType): Promise<string>
  commitTransaction(outCtx: UgcTraceCtx, transactionId: string): Promise<void>
  rollbackTransaction(outCtx: UgcTraceCtx, transactionId: string): Promise<void>
}
export interface UgcEntityApi {
  setParam(entityId: EntityId, key: string, val: unknown, userId?: HeapId): Promise<void>
}
export interface UgcJobsServiceApi {
  scheduleJobAt(
    ctx: EnvCtx,
    execAtMs: number,
    jobCallUrl: string,
    jobCallParams?: JSONInputValue,
    jobScheduleParams?: UgcJobScheduleParams,
    originStack?: string | null,
  ): Promise<string>
  scheduleJobAsap(
    ctx: EnvCtx,
    jobCallUrl: string,
    jobCallParams?: JSONInputValue,
    jobScheduleParams?: UgcJobScheduleParams,
    originStack?: string | null,
  ): Promise<string>
  scheduleJobAfter(
    ctx: EnvCtx,
    amount: number,
    unit: TimeUnit,
    jobCallUrl: string,
    jobCallParams?: JSONInputValue,
    jobScheduleParams?: UgcJobScheduleParams,
    originStack?: string | null,
  ): Promise<string>
  cancelJob(ctx: EnvCtx, jobId: string): Promise<void>
  pushToCustomJobQueue(
    ctx: UgcOutEnvCtx,
    queueName: string,
    ugcJobCallPath: string,
    ugcJobCallPayload: JSONInputObject,
    scheduleParams: CustomQueueJobScheduleParams,
    originStack?: string | null,
  ): Promise<CustomQueueJobId>
  pickFromCustomJobQueue(
    ctx: UgcOutEnvCtx,
    queueName: string,
    count: number,
  ): Promise<Array<[CustomQueueJobId, JSONObject]>>
  scheduleNextCustomJobQueueRunAfter(
    ctx: UgcOutEnvCtx,
    queueName: string,
    amount: number,
    unit: TimeUnit,
  ): Promise<void>
  deleteFromCustomJobQueue(ctx: UgcOutEnvCtx, queueName: string, jobId: CustomQueueJobId): Promise<void>
}
export interface UgcEmailServiceApi {
  sendEmail(params: SendEmailParams): Promise<SendEmailResult>
}
export interface UgcUgcServiceApi {
  findFile(path: string): Promise<UgcUgcServiceFile | null>
  updateCode(
    inCtx: {
      user: {
        id: string | null
      }
      env: Env
      lang: string
      timeZone: string
    },
    path: string,
    source: string,
  ): Promise<UgcUgcServiceFile>
}
export interface UgcUgcServiceFile {
  path: string
  source: string
}
export interface UgcSyncServiceApi {
  acquireLock(
    ctx: UgcTraceCtx,
    lockId: string | string[],
    options?: UgcSyncLockOptions,
  ): Promise<UgcSyncLockInfo | null>
  releaseLock(ctx: UgcTraceCtx, lockId: string | string[], lockValidationKey: string): Promise<void>
}
export interface UgcSyncLockInfo {
  lockValidationId: string
  wasWaiting: boolean
}
export interface UgcSyncLockOptions {
  timeoutMs?: number
  maxDurationMs?: number
}
export interface UgcInboxServiceApi {
  getInboxData(
    userId: string,
    options: {
      flat?: boolean
    },
  ): Promise<IsolatedVmTransferable<UgcInboxData>>
  updateInbox(recipientUserId: HeapId, params: UgcUpdateInboxParams): Promise<UgcInbox>
  resetInboxBadge(recipientUserId: HeapId, params: ResetInboxBadgeParams): Promise<UgcInbox | null>
}
export interface UgcUpdateInboxParams {
  url: string
  subjectId?: string | null
  title: string
  description: string | null
  icon?: UgcInboxIcon | null
  badge?: number
  data?: JSONObject | null
  sendPush?: boolean
  withSound?: boolean
  pushImageUrl?: string | null
}
export interface UgcSocketApi {
  genSocketId(unencodedSocketId: string): Promise<string>
  updateSocket(unencodedSocketId: string): Promise<void>
  sendDataToSocket(unencodedSocketId: string, data: JSONInputValue): Promise<void>
}
export interface UgcUserServiceApi {
  getOrCreateUserByAuth(authId: number): Promise<UgcCtxUser1>
  getOrCreateUserByEmail(email: string): Promise<UgcCtxUser1>
  getOrCreateUserByPhone(phone: string): Promise<UgcCtxUser1>
  getOrCreateUserByAuthTypeAndKey(authType: AuthType, key: string): Promise<UgcCtxUser1>
  findUserById(id: HeapId): Promise<UgcCtxUser1 | null>
  findUserWithAuthById(id: HeapId): Promise<[UgcCtxUser1, UgcCtxBaseAuth] | [null, null]>
  findUsersByIds(ids: string[]): Promise<UgcCtxUser1[]>
  findUsersWithAuthsByIds(ids: string[]): Promise<Array<[UgcCtxUser1, UgcCtxBaseAuth]>>
  findUsersByRole(role: UserRole | UserRole[]): Promise<UgcCtxUser1[]>
  createUser(
    reqCtx: {
      userId?: HeapId
    },
    userInfo: CreateRealUserInfo,
  ): Promise<[UgcCtxUser1, UgcCtxBaseAuth]>
  updateUserById(
    currentUserId: string | undefined,
    id: string,
    updateData: Partial<Pick<UgcCtxUser1, 'firstName' | 'lastName' | 'avatar'>>,
  ): Promise<UgcCtxUser1>
}
export interface UgcAppServiceApi {
  findAuthAccountsWithCurrentApp(authId: number): Promise<UgcAppServiceApiAccount[]>
  getAccountApps(): Promise<UgcAppServiceApiApp[]>
  getAccountUApps(): Promise<UgcAppServiceApiModule[]>
  getAccountRcLayout(env: Env): Promise<UgcAppServiceApiLayout>
  updateUAppSettings(userId: string, uappName: string, settingsSlug: string, value: object): Promise<void>
  readUAppSettings(uappName: string, settingsSlug: string, defaultValue?: object): Promise<object>
  appApiCall(
    authId: number,
    requestHeaders: Record<string, unknown>,
    requestQuery: ReqQuery,
    sessionId: string,
    appSlug: string,
    path: string,
    payload: Record<string, unknown>,
  ): Promise<AppApiCallResult>
  accountUgcInternalRequest<T extends UgcInternalRequestPayload>(
    ctx: UgcInternalCtx,
    loadFrom: UgcFileStorage,
    req: T,
  ): Promise<UgcMatchingInternalResponse<T>>
  accountUgcInternalRequestIfHasHook<T extends UgcInternalRequestPayload>(
    ctx: UgcInternalCtx,
    loadFrom: UgcFileStorage,
    req: T,
    ifHookName: string,
    elseRes: UgcMatchingInternalResponse<T>,
  ): Promise<UgcMatchingInternalResponse<T>>
  triggerDistributedHook(
    ctx: UgcInternalCtx,
    loadFrom: UgcFileStorage,
    hook: string,
    payload: JSONInputValue,
    method?: string,
    useSerializer?: boolean,
    timeoutMs?: number,
  ): Promise<JSONValue[]>
}
export interface AppApiCallResult {
  error?: any
  response?: Record<string, unknown>
}
export interface UgcFormStorageApi {
  setItem(key: string, value: UgcFormStorageAvailableValueType): Promise<void>
  getItem(key: string, defaultValue: UgcFormStorageAvailableValueType): Promise<UgcFormStorageAvailableValueType>
  removeItem(key: string): Promise<void>
  addToSet(key: string, member: string): Promise<number>
  removeFromSet(key: string, member: string): Promise<number>
  listSet(key: string): Promise<string[]>
}
export interface UgcHtmlServiceApi {
  renderHtml(routerPath: string, templatePath: string, props?: AnyObject): Promise<string | null>
  getDesktopBuiltinMapping(): Promise<undefined | DesktopBuiltinMapping>
}
declare type UgcFormStorageAvailableValueType_Plain = string | boolean | number | null
export declare type UgcFormStorageAvailableValueType =
  | Record<string, UgcFormStorageAvailableValueType_Plain>
  | UgcFormStorageAvailableValueType_Plain
export interface UgcAccountServiceApi {
  createMultiAuthAccount(
    requestCtx: AuthRequestCtx,
    userId: HeapId,
    name: string,
    options?: UgcCreateAccountOptions,
  ): Promise<UgcCtxAccount>
  getOwnedAccountsForUser(userId: HeapId): Promise<UgcAccount[]>
  findAccountById(id: number): Promise<UgcAccount | null>
  findAccountsByIds(ids: number[]): Promise<UgcAccount[]>
  getGetcourseAccountInfo(gcAccountId: number): Promise<GetcourseAccountInfo | null>
  installAppToChildAccount(appSlug: string, targetChildAccountId: number): Promise<void>
  updateChildAccountStartApp(targetChildAccountId: number, startAppSlug: string | null): Promise<void>
  getCurrentAccountSettings(): Promise<UgcAccount>
  updateCurrentAccountSettings(patch: UgcUpdateAccountSettings): Promise<void>
  installApp(appSlug: string): Promise<void>
  uninstallApp(appSlug: string): Promise<void>
  addAccountDomain(outCtx: UgcTraceCtx, props: AddAccountDomainProps): Promise<UgcDomain>
  setAccountPrimaryDomain(outCtx: UgcTraceCtx, accountId: number, domainId: number | null): Promise<void>
  calcAccountFullCodePublishedVersion(): Promise<string>
  /** @depraecated */
  persistentPlaygroundAccount(userId: HeapId, name: string, title?: string, logo?: Icon): Promise<UgcAccount | null>
  /** @depraecated */
  cloneEntityToAccount(
    userId: HeapId,
    sourceAccountName: string,
    destAccountName: string,
    sourceEntityPath: string,
    destEntityPath?: string,
  ): Promise<string>
}
export interface UgcDomain {
  id: Domain['id']
  name: Domain['name']
  pathPrefix: Domain['path_prefix']
  isReady: Domain['is_ready']
  controlType: DomainControlType
  dnsRecords: Domain['dns_records']
  lang: Domain['lang']
  createdAt: Domain['created_at']
}
export interface AddAccountDomainProps {
  accountId: number
  name: UgcDomain['name']
  controlType: DomainControlType
  lang?: UgcDomain['lang']
  dnsRecords?: UgcDomain['dnsRecords']
  pathPrefix?: UgcDomain['pathPrefix']
}
export interface UgcAccount extends UgcCtxAccount {
  title?: string
  image?: string | null
  lang?: Lang | null
  createdAt?: Date
}
export interface UgcCreateAccountOptions {
  title?: string
  image?: string
  type?: 'Chatium' | 'Playground'
  lang?: Lang | null
}
export interface UgcUpdateAccountSettings {
  title?: string
  image?: string | null
  lang?: Lang | null
}
export interface UgcAppServiceApiAccount {
  url: string
  title: string
  logo: Icon
}
export declare type UgcAppServiceApiLayout = Layout | undefined | string
export interface UgcAppServiceApiModule {
  id: string
  name: string | null
  icon: string | null
  title: string | null
  items: Array<any>
}
export interface UgcAppServiceApiApp {
  id: number
  name: string | null
  icon: string | null
  image: string | null
  cover: string | null
  description: string | null
  owner_id: number | null
  installed: boolean
  slug: string
  weight: number
  price: Money | undefined
  is_public: boolean
  is_active: boolean
  module?: UgcAppServiceApiModule
}
export declare type ClosureModule<T extends Record<string, unknown> = Record<string, unknown>> = (
  ctx: RichUgcCtxWithInternals,
) => T
export declare type IsolatedVmTransferable<T> = T extends Date
  ? string
  : T extends JSONValue | undefined
  ? T
  : T extends object
  ? {
      [K in keyof T]: IsolatedVmTransferable<T[K]>
    }
  : T extends Array<infer ArrayItem>
  ? Array<IsolatedVmTransferable<ArrayItem>>
  : never
export interface UgcIsolatedEvalServiceApi {
  isolatedEval(code: string, args: any[]): Promise<any>
}
export interface UgcAppMetricServiceApi {
  prepareMetricEvent(
    ctx: UgcAppMetricServiceCtx,
    data: UgcAppMetricServiceEventData | undefined,
    target: 'appHost' | 'account',
  ): Promise<MetricEventData>
  writeMetricEvent(
    ctx: UgcAppMetricServiceCtx & UgcOutEnvCtx,
    data: UgcAppMetricServiceEventData | undefined,
    target: 'appHost' | 'account',
  ): Promise<MetricEventData>
  subscribeToMetricEvents(
    ctx: UgcTraceCtx,
    subscriptions: Record<string, JSONInputValue>,
    groupKey: string | null,
    replaceGroup: boolean,
  ): Promise<void>
  unsubscribeFromMetricEvents(ctx: UgcTraceCtx, urlPathsOrGroupKey: string[] | string): Promise<void>
  __insertIntoTable(_ctx: UgcTraceCtx, db: string, table: string, rows: any[]): Promise<void>
  __queryClickHouse(
    _ctx: UgcTraceCtx,
    query: string,
    options: QueryClickHouseOptions,
    onDataCb?: Reference<any>,
  ): Promise<void>
}
export interface UgcAppMetricServiceCtx {
  req: {
    cookie: string | undefined
    userAgent: string | undefined
    url: string | undefined
    ip: string | undefined
    referrer: string | undefined
    fcmToken: string | undefined
    uid: string | undefined
    sid: string | undefined
    inferredUid: boolean
    inferredSid: boolean
  }
  account: {
    id: number
    type: string
  }
  user:
    | undefined
    | {
        id: string
        type: 'Anonymous' | 'Real' | 'Bot'
        firstName: string | undefined
        lastName: string | undefined
        accountRole: string | undefined
        image: string | undefined
        phone: string | undefined
        email: string | undefined
      }
  session:
    | undefined
    | {
        id: string | undefined
        phone: string | undefined
        email: string | undefined
      }
  auth:
    | undefined
    | {
        id: string
        phone: string | undefined
        email: string | undefined
      }
}
export declare type UgcAppMetricServiceEventData = Partial<Omit<MetricEventData, 'account'>>
export interface UgcAppMetricServiceModel {
  id: string
  heapType: string
}

export {}
